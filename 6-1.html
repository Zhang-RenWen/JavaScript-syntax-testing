<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript-syntax-learning</title>
  <link rel="stylesheet" href="./hightlight/default.min.css" />
  <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
  <link rel="stylesheet" href="./css/main.css" />
  <script src="./hightlight/hightlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <nav>
    <h1>現代 Javascript 實務應用</h1>
  </nav>
  <main>
    <aside></aside>
    <section>
      <h2>Chapter 6 運用代理器管理特性存取</h2>
      <p>
        代理器是 ES6 中一項有趣且具威力的特徵功能，它可作為物件和API 運用兩者之間居中協調的角色。概略地說，你可以使用一個 Proxy 代理器來決定偏好的存取 target 目標物件特性的方式。handler
        物件可用來設定你的代理器的條件，定義且限制底層物件被存取的方式，接下來我們將會進行探討。
      </p>
      <h2>6-1 代理器初探</h2>
      <p>
        在預設的條件下，代理器並不會做太多事情一事實上是根本不會做任何事。如果你不進行任何的設定，代理器就只像是一個通往 target 物件的通道，一般稱為「不管理的轉送代理器 (no-op forwarding
        proxy)」，意思為代理器物件上的所有操作均依從目標物件。
      </p>
      <p>
        在下面的程式範例，我們會建立一個不管理的轉送代理器 Proxy。你可以觀察到如何藉由為 proxy.exposed 指定一個值 ，來將值傳遞給
        target.exposed。你可以將代理器稅太目標物件的守門員：它可允許某些操作通過：禁止某些操作進得附他們會仔細地檢查每個與目標物件的互動操作‧
      </p>
      <pre><code class="language-js">
const target = {}
const handler = {}
const proxy = new Proxy(target, handler)
proxy.exposed = true
console.log(target.exposed)
// true
console.log(proxy.somethingElse)
// undefined
        </code></pre>
      <p>
        我們可以為代理器物件加入一些機關 (traps)，讓它更為有趣一些。機關可允許你用不同的方式攔截與 target 物件之間的互動行為，只要這些互動行為都是透過 proxy 物件進行。例如：我們可以使用一個 get
        機關將每個試圖擷取 target 目標物件特性的操作記錄下來，或是一個 set 機關來避免某些特性被寫入變更。下面讓我們先來學習 get 機關。
      </p>
      <h3 id="6-1-1">6-1-1 定義 get 機關攔截擷取操作</h3>
      <p>
        在下方程式碼的 proxy 能夠記錄每個特性被擷取的事件，因為它有一個 handler.get 機關。它也可以將欲擷取的特性值在提供給特性操作器之前，先將值進行轉換後再回傳。
      </p>
      <pre><code class="language-js">
const handler = {
  get(target, key) {
    console.log( `Get on property"${ key }"`)
    return target[ key]
  }
}
const target = {}
const proxy = new Proxy(target, handler)
proxy.numbers = [1, 1, 2, 3, 5, 8, 13]
proxy.numbers
// 'Get on property"numbers'
// [1, 1, 2, 3, 5, 8, 13]
proxy['something-else']
// 'Get on property"something-else"'
// undefined
        </code></pre>
      <p>
        ES6 也推出了一個內建的 Reflect 反射物件，功能與代理器互補。在ES6 代理器中所設定的機關與 Reflect 反射 API 有一對一對應關係：對每一個機關，在 Reflect
        中都會有一個對應的反射方法。當我們想要將預設的行為設定為代理器機關時，這些方法 會特別有效；但我們並不需要繼續往下瞭解它的實作方法。
      </p>
      <P>在下面的程式範例中，我們使用 Reflect.get 作為 get 操作的預設行為，同時也不需要擔心以手動的方式擷取 target 物件中的
        key特性在這個案例中，操作看起來可能很簡單，但在其他機關的預設行為可能更難正確地記憶和實作。我們可以將機關中的每一個參數都轉導至反射API 且將它的結果回傳。
      </P>
      <pre><code class="language-js">
const handler = {
  get(target, key) {
    console.log( `Get on property "${ key }"` )
    return Reflect.get(target, key)
  }
}
const target = {}
const proxy = new Proxy(target, handler)
        </code></pre>
      <P> get 機關不需要總是回傳原始 target[key] 的值。想像一下這樣的情境，你希望名稱以底線開頭的特性是不允許擷取的；在此情況下，你可以拋出一個錯誤，讓使用者知道該特性在透過代理器的檢查後是無法擷取的。
      </P>
      <pre><code class="language-js">
const handler = {
  get(target, key) {
    if (key.startsWith('_')) {
      throw new Error( `Property "${ key }" 特性不允許存取。` )
    }
    return Reflect.get (target, key)
  }
}
const target = {}
const proxy = new Proxy(target, handler)
proxy._secret
// Uncaught Error: "_secret" 特性不允許存取。
        </code></pre>
      <p>
        當能夠定義 target 目標物件的擷取規範時，逶過代理器的條件設定禁止某些特性的擷取，就變得非常的有用：而且不需要將 target
        物件暴露出來。就可以透過代理器使用‧以這樣的方式，你仍然可以自由地擷取目標物件，但是必須被強制透過代理器進行，並受限於定義的範圍，以精確地控制外界與物件互動的方式‧這在 ES6 推出代理器之前是不可能辦到的。
      </p>
      <pre><code class="language-js">

        </code></pre>
      <pre><code class="language-js">

        </code></pre>
      <pre><code class="language-js">

        </code></pre>
      <pre><code class="language-js">

        </code></pre>

      <div class="border-block"></div>
    </section>
  </main>
</body>
<script src="./menu.js"></script>

</html>