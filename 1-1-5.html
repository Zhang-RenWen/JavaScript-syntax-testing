<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-1-5">1-1-5 現代 CSS 特色</h2>
        <h3>CSS 變數和主題切換優雅實現</h3>
        <p>
          CSS 變數時代確實已經到來。注意，這裡所說的不是CSS 前置處理器（類似
          Less、Sass）中的變數，而是實實在在地原生支援特性。
        </p>
        <pre><code class="language-css">
main {
  background: white;
  color: #555;
}
a,
a:link {
  color: #639a67;
}
a:hover {
  color: #205d67;
}
        </code></pre>
        <p>借助 CSS 變數，我們可以對顏色色值進行設定。</p>
        <pre><code class="language-css">
:root {
  --bg: White;
  --text-color: #555;
  --link-color: #639a67;
  --link-hover: #205d67;
}
        </code></pre>
        <p>這樣一來，我們可以直接使用色值來實現程式簡化。</p>
        <pre><code class="language-css">
main {
  background: var (--bg);
  color: var (--text-color);
}
a,
a:link {
  color: var (--link-color);
}
a:hover {
  color: var (--link-hover);
}
        </code></pre>
        <p>
          這一點很好了解，在任何語言中，變數都是個好東西：它可以降低維護成本，甚至實現更好的效能。
        </p>
        <p>
          CSS 變數語法也很簡單：我們使用「--變數名稱」的方式定義變數，使用
          var(--變數名稱)的方式消費變數。
        </p>
        <p>
          CSS變數的相容性「出乎意料」得好，大部分行動端都已經可以使用 CSS 變數，PC
          端的新版本瀏覽器基本也都已經支援該變數。
        </p>
        <p>:root 使用方式是在 html 根節點下定義，並如上面的範例進行變數宣告。</p>
        <p>除了簡單地應用變數，下面介紹一些進階用法。</p>
        <h4>使用CSS變數實現主題切換</h4>
        <p>
          對於一鍵切換主題這一功能，以往的寶現方式較為複雜。如今，借助 CSS
          變數，一切都變得容易起來。參考以下程式。
        </p>
        <pre><code class="language-css">
:root {
  --bg: white;
  --text-color: #555;
}
        </code></pre>
        <p>定義一個，pink-theme 來對應粉色主題，程式如下。</p>
        <pre><code class="language-css">
.pink-theme {
  --bg: hotpink;
  --text-color: white;
}
        </code></pre>
        <p>指定套用的元素。</p>
        <pre><code class="language-css">
main {
  background: var(--bg);
  color: var(--text-color);
}
        </code></pre>
        <p>這樣一來，切換主題就變得非常簡單了，程式如下。</p>
        <pre><code class="language-js">
const toggleBtn = document.querySelector('.toggle-theme')
const main = document.querySelector('main')
toggleBtn.addEventListener('click', (e) => {
  e.preventDefault()
  if (main.classList.contains('pink-theme')) {
    // 目前主題為粉色主題，需要移除 pink-theme class
    main.classList.remove('pink-theme')
    toggleBtn.innerText = '切換為粉色少女主題'
  } else {
    main.classList.add('pink-theme')
    toggleBtn.innerText = '切換正常主題色'
  }
})
        </code></pre>
        <div class="border-block"><button class="toggle-theme">切換為粉色少女主題</button></div>
        <h4>CSS Modules 理論和實戰</h4>
        <p>
          如何維護大型專案的 z-index，如何維護 CSS 選擇器和樣式之間的衝突。是接下來這個單元的重點。
        </p>
        <h4>CSS Modules</h4>
        <p>
          CSS Modules是指，專案中的所有 class 名稱預設都是局部有作用的。 其實，CSS Modules
          並不是一個官方標準，更不是瀏覽器的機制，因為它依賴我們的專案建置過程，因此以它為基礎的實現常常需要借助
          webpack 或其他建置工具可以將 class 名稱唯一化，進一步使其只在局部有作用。
        </p>
        <pre><code class="language-html">
&lt;div class="test"&gt;This is a test&lt;/div&gt;
        </code></pre>
        <p>對應的樣式表如下。</p>
        <pre><code class="language-css">
.test{
  color: red
}
        </code></pre>
        <p>經過編譯建置後，對應的 HTML 程式內容如下所示。</p>
        <pre><code class="language-html">
&lt;div class="_style_test_309571057"&gt;
  This is a test
&lt;/div&gt;
        </code></pre>
        <p>同時，經過編譯建置後，對應的 CSS 程式內容如下所示。</p>
        <pre><code class="language-css">
._style_test_309571057{
  color: red;
}
        </code></pre>
        <p>
          其中，class
          名是動態產生的，在整個專案中這個名字是唯一的。透過命名標準的唯一性，便達到了避免樣式衝突的目的。
        </p>
        <p>
          仔細想來，這樣的解決方案似乎有一個問題：如何實現樣式重複使用？因為產 生了全域唯一的 class
          名，所以我們如何像傳統方式那樣實現樣式重複使用呢？ 從原理上想，全域唯一的 class
          名是在建置過程中產生的，所以如果能夠在建置過程中進行標識，表示該 class
          將被重複使用，就可以解決問題了。
        </p>
        <p>
          這樣的方式需要依靠 composes 關鍵字實現。我們來看一個實際範例。 在專案樣式表 style.css
          檔案中，有以下相關程式。
        </p>
        <pre><code class="language-css">
.common { 
  color: red;
}
.test {
  composes: common; 
  font-size: 18px;
}
        </code></pre>
        <p>注意，這裡使用 composes 關鍵字在 .test 中連結了 .common 樣式。</p>
        <p>專案的HTML 檔案中引用了 style.css檔案，並使用了 CSS Modules特性，程式如下。</p>
        <pre><code class="language-html">
import style from "./style.css"; 
&lt;div class="${style.test}"&gt;
  This is a test
&lt;/div&gt;
        </code></pre>
        <p>以上程式經過編譯建置後，獲得的程式如下。</p>
        <pre><code class="language-html">
&lt;div class="_style__test_0980340_style_common_404840"&gt;
  This is a test 
&lt;/div&gt;
        </code></pre>
        <p>我們看到， div 的 class 中加入了 _style_common_404840 ，這樣就實現了重複使用樣式‧</p>
        <h4>CSS Modules 實戰</h4>
        <p>本節將使用 webpack 來建置一個專案，一步一步進行分析說明。</p>
        <h5>1.建立專案</h5>
        <p>透過指令 npm init -y 進行專案初始化建立。 此時產生的 package.json 檔案中的內容如下。</p>
        <pre><code class="language-json">
{
  "name": "css-modules",
  "version": "1.0.0",
  "description": "README. md",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
}
        </code></pre>
        <h5>2.建立必要檔案</h5>
        <p>
          輸入指令 mkdir src 來建立 src 檔案，同時在該目錄下建立 index.html 檔案，指令是 touch
          index.html。接著，在 ./src 資料夾中建立 index.js、style.css 和 app.css 檔案。
        </p>
        <p>其中 index.js 檔案中的程式如下。</p>
        <pre><code class="language-js">
import blueStyle from './style.css'
import greenStyle from './app.css'
let html = `
&lt;h2 class="${bluestyle.my_css_selector}"&gt;I should be displayed in blue.&lt;/h2&gt;
&lt;br/&gt;
&lt;h2 class="${greenstyle.my_css_selector}"&gt;I should be displayed in green.&lt;/h2&gt;`
document.write(html)
        </code></pre>
        <p>style.css 檔案中的程式如下。</p>
        <pre><code class="language-css">
.my_css_selector{
  color: blue;
}
        </code></pre>
        <p>app.css 檔案中的程式如下。</p>
        <pre><code class="language-css">
.my_css_selector {
  color: green;
}
        </code></pre>
        <p>在 style.css 和 app.css 這兩個樣式檔案中，使用了相同的 class 名。</p>
        <h5>3.安裝依賴</h5>
        <p>
          接下來安裝 webpack、webpack-cli、Babel 全家桶(babel-core、babel-loader、 abel-preset-env
          )、對應的 loaders ( css-loader 、 style-loader) 及 extract-text-webpack-plugin 外掛程式。
        </p>
        <p>
          強烈建議安裝版本遵循以下程式設定，否則會出現類似 webpack 版本和
          extract-text-webpack-plugin 不相容等版本依賴問題。
        </p>
        <pre><code class="language-json">
{
  "babel-core": "^6.26.3",
  "babel-loader": "^7.1.4",
  "babel-preset-env": "^1.6.1",
  "css-loader": "^0.28.11",
  "extract-text-webpack-plugin": "^4.0.0-beta.0",
  "style-loader": "^0.21.0",
  "webpack": "^4.1.0",
  "webpack-cli": "^3.1.1"
}
        </code></pre>
        <p>按照正常流程走下來，package.json 檔案中的程式如下所示。</p>
        <pre><code class="language-json">
{
  "name": "css-modules",
  "version": "1.0.0",
  "description": "[README.md](http://readme.md/)",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-loader": "^7.1.4",
    "babel-preset-env" : "^1.6.1",
    "css-loader": "^0.28.11",
    "extract-text-webpack-plugin": "^4.0.0-beta.0",
    "style-loader": "^0.21.0",
    "webpack" : "^4.1.0",
    "webpack-cli": "^3.1.1"
  }
}
        </code></pre>
        <h5>4.撰寫 webpack 設定</h5>
        <p>建立 webpack 設定檔，如下。</p>
        <pre><code class="language-bash">
touch webpack.config.js
        </code></pre>
        <p>撰寫 webpack 設定內容，如下。</p>
        <pre><code class="language-js">
var ExtractTextPlugin = require('extract-text-webpack-plugin')
module.exports = {
  entry: './src',
  output: {
    path: __dirname + '/build',
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.js/,
        loader: 'babel-loader',
        include: __dirname + '/src'
      },
      {
        test: /\.css/,
        loader: ExtractTextPlugin.extract(
          'css-loader?modules&importLoaders=1&localIdentName=[name]__[local]__[hash: base64:5]'
        )
      }
    ]
  },
  plugins: [new ExtractTextPlugin('styles.Css')]
}
        </code></pre>
        <p>
          這裡使用了 extract-text-webpack-plugin 外掛程式，並定義外掛程式分析入口為./sre
          目錄，外掛程式進行處理後，輸出結果到 __dirname + '/build' 目錄中。 對副檔名為 .css
          的檔案使用 css-loader 進行解析，輸出樣式內容到 styles.css 檔案中，並在 index.html
          檔案中引用 styles.css 檔案。 注意，這裡為 css-loader 設定了 modules 參數，並進行了 CSS
          Modules 處理。
        </p>
        <h5>5.撰寫 npm script 並執行</h5>
        <p>最後，將 package.json 中的 script 指令改為以下形式。</p>
        <pre><code class="language-json">
"scripts": {
  "start": "webpack --mode development"
}
        </code></pre>
        <p>使用 npm run stat 指令來執行 webpack，此時 package.json 檔案中的程式如下。</p>
        <pre><code class="language-json">
{
  "name": "css-modules",
  "version": "1.0.0",
  "description": "README.md",
  "main": "index.js",
  "scripts": {
    "start": "webpack --mode development"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.26.3",
    "babel-loader": "^7.1.4",
    "babel-preset-env" : "^1.6.1",
    "css-loader": "^0.28.11",
    "extract-text-webpack-plugin": "^4.0.0-beta.0",
    "style-loader": "^0.21.0",
    "webpack" : "^4.1.0",
    "webpack-cli": "^3.1.1"
  }
}
        </code></pre>
        <p>
          執行 npm start，獲得輸出，開啟頁面會發現，在編譯過程中完成了對樣式的 CSS Modules 處理。
        </p>
        
        <h3>響應式版面配置</h3>
        <p>
          首先來整理一下響應式版面配置的幾種典型方案，實際如下。
        </p>
        <ul>
          <li>傳統版面配置</li>
          <li>相對單位版面配置</li>
          <li>透過媒體查詢實現的響應式版面配置</li>
          <li>以相對單位 rem 為基礎的 fexible 版面配置</li>
          <li>flex 版面配置</li>
          <li>grid 版面配置</li>
          <li>借助 JavaScript 進行版面配置</li>
        </ul>
        <p>前面內容配置為傳統式排版，實現較為複雜，同時對整體版面配置入侵影響較大，除了傳統版面配置，我們還會經常用到相對單位版面配置，這種實現方式比較容易了解，下面就來整理一下 CSS中的相對單位。</p>
        <ul>
<li>em</li>
<li>rem</li>
<li>vh vw vmin vmax</li>
<li>%</li>
<li>calc()</li>
</ul>

<p>這裡的重點是了解這些相對單位的使用標準，也就是「到底是相對於誰」（注意，這也是一個很重要的面試考點）。</p>

<ul>
<li>
em 相對目前元素或目前元素繼承來的字型的寬度，但是每個字母或中文字的寬度有可能是不一樣的，一般來說是一個大寫字母M的寛度（事實上，標準中有一個 x-height 概念，建議取X的高度，但並沒有推薦絕對的計算執行標準，還需要看瀏覽器的實現，也有的地方採用O的高度）；一個非常容易出錯的點在於，很多同學會認為em 相對父元素的字型大小，但是實際上「相對於誰」取決於應用在什麼 CSS 屬性上。對於 font-size 來說，em 是相對於父元素的字型大小；在 line-height 中，em 卻是相對於本身的字型大小。
</li>
<li>rem 相對於根節點（html）的字型大小。</li>
<li>vw 相對於視埠寬度，100vw 就相當於一個視埠寬度。</li>
<li>vh 與 vw 同理，1vh表示一個視埠高度的1/100。</li>
<li>vmin Math.min(vw,vh)相對於視埠範圍中較小的那一個數值，也就是 vw vh 中取最小值。相對的 vmax Math.max(vw,vh) 就是在 vh vw 中取最大值。</li>
<li>% 顯示相對於父層多少比例範圍。</li>
<li>calc 是一個響應式版面配置計算單位，它使得CSS有了運算的能力。舉例來說，以下程式實現了根據螢幕寬度進行計算的功能。
</li>
</ul>
<pre><code class="language-css">
width: calc(100vw - 80px) 
</code></pre>
<h3>真實線上轉換案例分析</>
<p>羅列一下其他關於響應式版面配置的概念，</p>
<ul>
<li>螢幕解析度</li>
<li>像素(px)</li>
<li>PPI(Pixel Per Inch)：每英吋包含的像素數</li>
<li>DPI(Dot Per Inch)：每英吋包含的點數</li>
<li>裝置獨立像素</li>
<li>裝置像素比(dpr)</li>
<li>Meta Viewport</li>
</ul>
<p>首先，淘寶透過設定以下程式來禁用使用者縮放功能，使真面寬度和裝置寬度對齊（如圖11-1 所示），這種操作一般也是行動端響應式轉換的標準配備。</p>
補圖片        
        <pre><code class="language-html">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
        </code></pre>
        <p>在頁面根節點 html 元素上顯性設定了 fout-size、如圖11-2補圖片</p>
        補2張圖片
        <p>在此基礎上，嘗試改變瀏覽器大小時，html 的 font-size 就會動態發生變化。這其實不難了解，採用 rem 作為相對單位的長寬數值都會隨著 resize 事件進行變化，因為html的 font-size 是動態變化的。在其頁面中，也不難找到如圖11-3所示的程式。</p>
        <p>這段程式的格式進行美化，可以獲得以下樣式的程式。</p>
        <pre><code class="language-js">
!function(e, t){
var n= t.documentElement,
d = e.devicePixelRatio || 1;
function i() {
var e = n.clientWidth / 3.75;
n.style. fontSize = e + "px"
}
if(function e(){
t.body? t.body.style.fontSize = "16px" : t.addEventListener("DOMContent Loaded", e)}),
i(), e.addEventListener ("resize", i), e.addEventListener("pageshow",
function (e){
e. persisted && i()}),2<=d){
var o = t.createElement ("body"),
a = t.createElement("div");
a. style.border = ".5px solid transparent", o.appendChild(a),
n.appendChild(o), 1 === a.offsetHeight & n.classList.add("hairlines"),
n.removeChild(o)
}
}(window, document)
        </code></pre>
        <p>以上程式是一個IIFE，在 DOMContentLoaded、resize、pageshow 事件觸發時，會對 html 的 font-size 值進行設定，計算方式如下。
        <pre><code class="language-js">
font-size = document. documentElement.clientWidth / 3.15
        </code></pre>
        <p>為什麼這麼計算呢？淘寶的工程師是按照 375px 的視覺稿進行開發的。在375px的視覺稿下，html 的 font-size 為 100，那如果寬度是 75px 的元素，就可以設定為 0.75rem（100 * 0.75 - 75px）；當裝置寬度為
414px(iPhone8 plus）時，我們想讓上述元素的寬度等比例自我調整到 82.8px(75 * 414/375)，那麼在 CSS 樣式為 0.75rem 不變的前提下，想計算獲得
82.0px，只需便 html 中的 font-size 變為 110.4px 即可 (110.4 * 0.75 = 82.8）。
那麼反過來，這個 110.4 的計算公式就如下所示。
        </p>
        <pre><code class="language-js">
document.documentElement.clientWidth / 3.75
        </code></pre>
        <p>再來看一看網易的做法。</p>
        <p>可以看出這裡同樣採用了 rem 版面配置，但與淘寶的差別是網易並沒有透過 JavasSerpt 計算 html 中的 font-size ，而是透過媒體查詢和 calc()，「列舉」了不同裝置下不同的 html 的 font-size 值。</p>
        <p>在頁面中，教為複雜的頭部 slider 元件的寬度明顯是 JS（取得裝置寬度後動態設定值的（圖11-6中為 414px），而高度則採用了
rem 版面配置來取得，圖11-6 中的 高度3.7rem=55.3px(calc(13.3333330)*3.7)
            </p>
        補圖片
        補圖片
                <pre><code class="language-css">

        </code></pre>
                <pre><code class="language-css">

        </code></pre>
        <pre><code class="language-css">

        </code></pre>
        <pre><code class="language-css">

        </code></pre>

        <div class="border-block"></div>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
  <script>
    const toggleBtn = document.querySelector('.toggle-theme')
    const main = document.querySelector('main')
    toggleBtn.addEventListener('click', (e) => {
      e.preventDefault()
      if (main.classList.contains('pink-theme')) {
        // 目前主題為粉色主題，需要移除 pink-theme class
        main.classList.remove('pink-theme')
        toggleBtn.innerText = '切換為粉色少女主題'
      } else {
        main.classList.add('pink-theme')
        toggleBtn.innerText = '切換正常主題色'
      }
    })
  </script>
</html>
<style>
  :root {
    --bg: white;
    --text-color: #000;
  }
  .pink-theme {
    --bg: hotpink;
    --text-color: white;
  }
  main {
    background: var(--bg);
    color: var(--text-color);
  }
</style>
