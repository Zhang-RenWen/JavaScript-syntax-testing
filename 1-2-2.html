<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2>1-2-2 閉包</h2>
        <p>
          開包是 JavaScript
          中最基本也是最重要的概念之一，涉及作用域、作用域鏈、執行上下文、記憶體管理等多重基礎知識。
        </p>
        <h3>作用域</h3>
        <p>
          函數作用域和全域作用域 ，舉例來說，執行以下 foo 函數時，變數 bar 在 函數 foo
          的作用域內，因此可以在函數本體內正常存取該變數，並輸出 bar。
        </p>
        <pre><code class="language-js">
function foo(){
  var bar = 3
  console.log(bar)
}
foo()
        </code></pre>
        <p>
          執行以上程式會輸出
          <code>undefined</code>
          ，原因是變數 bar 在函數內進行了提升。以上程式與以下程式結果是相等的。
        </p>
        <pre><code class="language-js">
function foo(){
  var bar
  console.log(bar)
  bar = 3
}
foo ()
        </code></pre>
        <p>
          但是，在使用
          <code>let</code>
          對 bar 進行宣告時（如下所示）則會顯示出錯
          <code>Uncaught ReferenceError: bar is not defined。</code>
        </p>
        <pre><code class="language-js">
function foo(){
  console.log(bar)
  let bar = 3   // Uncaught ReferenceError: bar is not defined。
}

foo()
        </code></pre>
        <p>
          我們知道，使用
          <code>let</code>
          或
          <code>const</code>
          宣告變數時會針對這個變數形成一個封閉的區塊級作用域，在這個區塊級作用域中，如果在宣告變數前存取該變數，就會出
          現
          <code>referenceError</code>
          錯誤；如果在宣告變數俊存取該變數，則可以正常取得變數值，範例如下。
        </p>

        <pre><code class="language-js">
function foo(){
  let bar = 3
  console.log(bar) // 3
}
foo()
        </code></pre>
        <p>
          在對應大括號形成的作用域中存在一個「死區」，起始於函數開頭，終止於相關變數宣告敘述的所在行。在這個範圍
          內無法存取使用
          <code>let</code>
          或
          <code>const</code>
          宣告的變數。這個「死區」，的專業名稱為 TDE (Temporal Dead Zone)，相關語言標準的介紹可參考
          ECMA Script@ 2015 Language Specification。
        </p>
        <pre><code class="language-js">
function foo(){
  // TDZ
  let bar = 3
  console.log(bar) // 3
}
foo()
           </code></pre>
        <p>以下舉一個特別的例子:</p>
        <pre><code class="language-js">
function foo(arg1 = arg2 , arg2){
  console.log(`${arg1} ${arg2}`) 
}
foo('arg1','arg2') // 'arg1 arg2'
        </code></pre>
        <p>
          在上面的 foo 函數中，如果没有傳入第一個參數，則會使用第二個參數作為第
          一個實際參數。呼叫以上程式，傳回內容正常；但是當第一個參數為預設值 undefined 時，執行 arg1
          = arg2 會被當作暫時性死區處理，範例如下:
        </p>
        <pre><code class="language-js">
function foo(arg1 = arg2, arg2){
  console.log(`${arg1} ${arg2}`)
}
foo(undefined,'arg2')
// Uncaught ReferenceError : arg2 is not defined
        </code></pre>
        <p>
          以上程式的輸出結果存在問題是因為除了區塊級作用域，函數參數預設值也會受到暫時性死區的影響。
        </p>
        <pre><code class="language-js">
function foo(arg1 = arg2, arg2){
  console.log(`${arg1} ${arg2}`)
}
foo(null,'arg2') // 'null arg2'

        </code></pre>
        <p>
          這就有關 undefined 和 null 的區別了。在執行 foo(null, 'arg2')
          時，不會認為「函數第一個參數為預設值」，而會直接接收 null 作為第一個參數的值。
        </p>
        <pre><code class="language-js">
function foo(arg1){
  let arg1 
}
foo('arg1') // Uncaught SyntaxError: Identifier 'arg1' has already been defined 
        </code></pre>
        <h3>執行上下文和呼叫堆疊</h3>
        <h4>程式執行的兩個階段</h4>
        <ul>
          <li>程式預先編譯階段</li>
          <li>程式執行階段</li>
        </ul>
        <p>
          預先編譯階段是前置階段，這一階段會由編譯器將 JavaScript
          程式編譯成可執行的程式。注意，這裡的預先編譯和傳統的編譯不同，傳統的編譯非常複雜，涉及分詞、解析、程式產生
          等過程。這裡的預先編譯是 JavaScript 中的獨特概念，雖然 JavaScript
          是直譯型語言，編譯一行，執行一行。但是在程式執行前，JavaScript
          引擎確實會做一些「預先準備工作」。
        </p>
        <p>執行時的主要任務是執行程式邏輯，執行上下文在這個階段會全部建立完成。</p>
        <p>
          在透過語法分析，確認語法無誤之後，便會在預先編譯階段對 JavaScript
          程式中變數的記憶體空閒進行分配，我們熟悉的變數提升過程便是在此階段完成的。
        </p>
        <p>對於預先編譯過程中的一些細節，我們應該注意以下 3 點。</p>
        <ul>
          <li>在預先編譯階段進行變數宣告。</li>
          <li>在預先編譯階段對變數宣告進行提升，但是值為 undefined。</li>
          <li>在預先編譯階段對所有非運算式的函數宣告進行提升。</li>
        </ul>
        <pre><code class="language-js">
function bar(){
  console.log('bar1')
}
var bar = function(){
  console.log ('bar2')
}
bar() // 'bar2'
        </code></pre>
        <p>會輸出 bar2 ，接著我們調換程式順序，執行以下程式。</p>
        <pre><code class="language-js">
var bar = function(){
  console.log ('bar2')
} 
function bar(){
  console.log ('bar1')
}
bar() // 'bar2'
        </code></pre>
        <p>
          以上輸出結果原因為在預先編譯階段雖然對變數 bar 進行了宣告，但是不會設定值；函數 bar
          則被建立並提升。在程式執行時，變數 bar才會（透過運算式）被設定值，設定值的內容是函數本體為
          console.log(bar2)的函數，輸出結果為 bar2。
        </p>
        <pre><code class="language-js">
foo(10)
function foo(num){
  console.log(foo)
  foo = num;
  console.log(foo)
  var foo
}
console.log(foo)
foo = 1
console.log(foo)
        </code></pre>
        <p>執行以上程式，輸出結果如下。</p>
        <pre><code class="language-js">
// undefined
// 10
// foo (num){
//   console.log(foo)
//   foo = num
//   console.log(foo)
//   var foo
// }
// 1
        </code></pre>
        <p>
          在foo(10)即時執行，會在函數本體內進行變數提升，此時執行函數本體內的第一行會輸出 undefined
          ，執行函數本體內的第三行會輸出 foo。接著執行 程式，執行到函數本體外的 console.log(foo)
          敘述時，會輸出 foo 函數的內容 (因為foo函數內的 foo =num ， num 被設定值給函數作用域內的
          foo 變數)
        </p>
        <p>
          上題的結論是，作用域在預先編譯階段確定，但是作用域鏈是在執行上下文
          的建立階段完全產生的，因為函數在呼叫時才會開始建立對應的執行上下
          文。執行上下文包含變數物件、作用域鏈及 this 的指向。
        </p>
        <p>
          程式執行的整個過程說起來就像一條生產管線。第一道工序是在預先編譯階段建立變數物件 (
          Variable Object ， VO)，此時只是建立，而未進行設定值。
          到了下一道工序程式執行時，變數物件會轉為啟動物件 (Active Object,AO)， 即完成 VO 向 AO
          的轉換。此時，作用域鏈也將被確定，它由目前執行環境的
          變數物件和所有外層已經完成的啟動物件組成。這道工序確保了變數和函數
          的有序存取，即如果未在目前作用域中找到變數，則會繼續向上尋找直到全域作用域。
        </p>
        <p>這樣的工序在管線上串成一個整體，便是 JavaScript 引擎執行機制最基本的原理。</p>
        <h3>呼叫堆疊</h3>
        <p>
          了解了上面的內容，函數呼叫堆疊便很好了解了。在執行一個函數時，如果
          這個函數又呼叫了另外一個函數，而這「另外一個函數」又呼叫了另外一個
          函數，這樣便形成了一系列的呼叫堆疊，程式如下。
        </p>
        <pre><code class="language-js">
function foo1(){
  foo2()
}

function foo2() {
  foo3 ()
}

function foo3()
  foo4(){
}

function foo4(){
  console.log('foo4')
}

foo1()
        </code></pre>
        <p>
          不管使用哪種方式，我們都可以從中借助 JavaScript
          引擎清晣地看到錯誤堆疊資訊，並由此看出函數呼叫關係。
        </p>
        <p>
          在函數執行完畢並移出堆疊時，函數內的區域變數在下一個垃圾回收（GC）節點會被回收，該函數對應的執行上下文將被銷毀，這也正是我們在外界無法存取函數內定義的變數的原因。也就是說，只有在函數即時執行，相關函數才可以存取該變數，該變數會在預先編譯階段被建立，在執行時被啟動，在函數執行完畢後，其相關上下文會被銷毀。
        </p>
        <h3>閉包</h3>
        <p>先來看一個簡單的範例，程式如下。</p>
        <pre><code class="language-js">
function numGenerator(){
  let num = 1
  num++
  return () =&gt;{
    console.log(num)
  }
}

var getNum = numGenerator()
getNum ()
        </code></pre>
        <p>
          在這個簡單的閉包範例中，numGenerator 建立了一個變數 num ，接著傳回列 印
          num值的匿名函數，這個函數參考了變數 num，使得在外部可以透過呼叫 getNum 方法存取變數
          num，因此在numGenerator 執行完畢後，即相關呼叫堆
          疊移出堆疊後，變數num不會消失，仍然有機會被外界存取。
        </p>
        <p>執行以上程式，我們能清晰地看到 JavaScript 引擎對執行過程的分析，如圖 下圖所示。</p>
        <span>圖1</span>
        <img src="/assets/image/1-2-2/1.jpeg" alt="" />
        <span>圖2</span>
        <img src="/assets/image/1-2-2/2.jpeg" alt="" />
        <p>num 值被標記為 Closure，即閉包變數。</p>
        <p>
          比較前述內容，我們知道在正常情況下外界是無法存取函數內部變數的，函數執行之後，上下文即被銷毀。但是在函數（外層）中，如果我們傳回了另一個函數，且這個傳回的函數使用了函數（外層）內的變數，那麼外界便能夠透過這個傳回的函數取得原函數（外層）內部的變數值。這就是閉包的基本原理。
        </p>
        <p>
          因此，直觀上來看，閉包這個概念為 JavaScript
          中存取函數內部變數提供了途徑和便利。這樣做的好處很多，舉例來說，我們可以利用閉包實現
          「模組化」;再舉例來說，翻看Redux
          原始程式的中介軟體實現機制，會發現其中也大量運用了開包（函數式理念）。
        </p>
        <pre><code class="language-js">
        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
