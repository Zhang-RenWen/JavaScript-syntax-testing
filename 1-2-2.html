<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2>1-2-2 閉包</h2>
        <p>
          開包是 JavaScript
          中最基本也是最重要的概念之一，涉及作用域、作用域鏈、執行上下文、記憶體管理等多重基礎知識。
        </p>
        <h3>作用域</h3>
        <p>
          函數作用域和全域作用域 ，舉例來說，執行以下 foo 函數時，變數 bar 在 函數 foo
          的作用域內，因此可以在函數本體內正常存取該變數，並輸出 bar。
        </p>
        <pre><code class="language-js">
function foo(){
  var bar = 3
  console.log(bar)
}
foo()
        </code></pre>
        <p>
          執行以上程式會輸出
          <code>undefined</code>
          ，原因是變數 bar 在函數內進行了提升。以上程式與以下程式結果是相等的。
        </p>
        <pre><code class="language-js">
function foo(){
  var bar
  console.log(bar)
  bar = 3
}
foo ()
        </code></pre>
        <p>
          但是，在使用
          <code>let</code>
          對 bar 進行宣告時（如下所示）則會顯示出錯
          <code>Uncaught ReferenceError: bar is not defined。</code>
        </p>
        <pre><code class="language-js">
function foo(){
  console.log(bar)
  let bar = 3   // Uncaught ReferenceError: bar is not defined。
}

foo()
        </code></pre>
        <p>
          我們知道，使用
          <code>let</code>
          或
          <code>const</code>
          宣告變數時會針對這個變數形成一個封閉的區塊級作用域，在這個區塊級作用域中，如果在宣告變數前存取該變數，就會出
          現
          <code>referenceError</code>
          錯誤；如果在宣告變數俊存取該變數，則可以正常取得變數值，範例如下。
        </p>

        <pre><code class="language-js">
function foo(){
  let bar = 3
  console.log(bar) // 3
}
foo()
        </code></pre>
        <p>
          在對應大括號形成的作用域中存在一個「死區」，起始於函數開頭，終止於相關變數宣告敘述的所在行。在這個範圍
          內無法存取使用
          <code>let</code>
          或
          <code>const</code>
          宣告的變數。這個「死區」，的專業名稱為 TDE (Temporal Dead Zone)，相關語言標準的介紹可參考
          ECMA Script@ 2015 Language Specification。
        </p>
        <pre><code class="language-js">
function foo(){
  // TDZ
  let bar = 3
  console.log(bar) // 3
}
foo()
           </code></pre>
        <p>以下舉一個特別的例子:</p>
        <pre><code class="language-js">
function foo(arg1 = arg2 , arg2){
  console.log(`${arg1} ${arg2}`) 
}
foo('arg1','arg2') // 'arg1 arg2'
        </code></pre>
        <p>
          在上面的 foo 函數中，如果没有傳入第一個參數，則會使用第二個參數作為第
          一個實際參數。呼叫以上程式，傳回內容正常；但是當第一個參數為預設值 undefined 時，執行 arg1
          = arg2 會被當作暫時性死區處理，範例如下:
        </p>
        <pre><code class="language-js">
function foo(arg1 = arg2, arg2){
  console.log(`${arg1} ${arg2}`)
}
foo(undefined,'arg2')
// Uncaught ReferenceError : arg2 is not defined
        </code></pre>
        <p>
          以上程式的輸出結果存在問題是因為除了區塊級作用域，函數參數預設值也會受到暫時性死區的影響。
        </p>
        <pre><code class="language-js">
function foo(arg1 = arg2, arg2){
  console.log(`${arg1} ${arg2}`)
}
foo(null,'arg2') // 'null arg2'

        </code></pre>
        <p>
          這就有關 undefined 和 null 的區別了。在執行 foo(null, 'arg2')
          時，不會認為「函數第一個參數為預設值」，而會直接接收 null 作為第一個參數的值。
        </p>
        <pre><code class="language-js">
function foo(arg1){
  let arg1 
}
foo('arg1') // Uncaught SyntaxError: Identifier 'arg1' has already been defined 
        </code></pre>
        <h3>執行上下文和呼叫堆疊</h3>
        <h4>程式執行的兩個階段</h4>
        <ul>
          <li>程式預先編譯階段</li>
          <li>程式執行階段</li>
        </ul>
        <p>
          預先編譯階段是前置階段，這一階段會由編譯器將 JavaScript
          程式編譯成可執行的程式。注意，這裡的預先編譯和傳統的編譯不同，傳統的編譯非常複雜，涉及分詞、解析、程式產生
          等過程。這裡的預先編譯是 JavaScript 中的獨特概念，雖然 JavaScript
          是直譯型語言，編譯一行，執行一行。但是在程式執行前，JavaScript
          引擎確實會做一些「預先準備工作」。
        </p>
        <p>執行時的主要任務是執行程式邏輯，執行上下文在這個階段會全部建立完成。</p>
        <p>
          在透過語法分析，確認語法無誤之後，便會在預先編譯階段對 JavaScript
          程式中變數的記憶體空閒進行分配，我們熟悉的變數提升過程便是在此階段完成的。
        </p>
        <p>對於預先編譯過程中的一些細節，我們應該注意以下 3 點。</p>
        <ul>
          <li>在預先編譯階段進行變數宣告。</li>
          <li>在預先編譯階段對變數宣告進行提升，但是值為 undefined。</li>
          <li>在預先編譯階段對所有非運算式的函數宣告進行提升。</li>
        </ul>
        <pre><code class="language-js">
function bar(){
  console.log('bar1')
}
var bar = function(){
  console.log ('bar2')
}
bar() // 'bar2'
        </code></pre>
        <p>會輸出 bar2 ，接著我們調換程式順序，執行以下程式。</p>
        <pre><code class="language-js">
var bar = function(){
  console.log ('bar2')
} 
function bar(){
  console.log ('bar1')
}
bar() // 'bar2'
        </code></pre>
        <p>
          以上輸出結果原因為在預先編譯階段雖然對變數 bar 進行了宣告，但是不會設定值；函數 bar
          則被建立並提升。在程式執行時，變數 bar才會（透過運算式）被設定值，設定值的內容是函數本體為
          console.log(bar2)的函數，輸出結果為 bar2。
        </p>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
