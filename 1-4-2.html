<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.//normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.///clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-4-2">1-4-2 效能最佳化</h2>
        <p>
          一直以來,效能最佳化都是前端的重要課題,不僅能實實在在地影響產品效能,也會在面試環節被反覆提及。無論面試者是初入前端的新手,還是經驗豐富的老手,面試官都能在效能方面找到合適的切入點,對面試者進行考驗。
        </p>
        <p>
          前端效能是一個太過寬泛的話題,脱離場景和需求談效能常毫無意義。很少有面試官會直接拋出「如何最佳化前端效能」這樣一個空架子問題。也不會有技術經理直接丟給你「把產品效能提升一些」這樣的專案。畢竟這樣的問題太大,根本讓人無從下手。需要針對實際場景和瓶頸來分析。
        </p>
        <p>但是,如果面試官真的這麼問了該怎麼辦呢?</p>
        <p>
          也許會這樣回答會比較洽當:前端效能涉及很多方面,最佳化角度和切入點都有所不同;主要可以分為頁面專案最佳化和程式細節最佳化兩大方向。頁面專案最佳化可以從頁面請求開始,涉及網路通訊協定、資源設定、瀏覽器效能、快取等;程式節最佳化方面的工作相對零散,舉例來說，要了解
          JavaScript 對 Dom 的操作過程、宿主還境及單執行緒的相關內容等，以寫出效能人性化的程式。
        </p>
        <p>
          為了更進一步地還原真實場景,下面將配合開放例題和程式例题這兩種面試題目從以上兩方面進行解析。
        </p>
        <h3>開放例題</h3>
        <p>平時做過哪些效能最佳化的案例？</p>
        <p>回答思路：</p>
        <ul>
          <li>1.介紹專案規模:造訪流量、金流量</li>
          <li>2.介紹用戶面向: To C 指 To Consumer (對消費者)，To B 是To Business (對企業)</li>
          <li>3.具體優化策略項目名稱，方案可以參考以下案例</li>
        </ul>
        <p>
          特別注意，因為不知道面試官具體會問多細，於是需要避免侃侃而談，點到策略名稱為止即可。主動權交給面試官，一般他們會針對有興趣的點優化策略加深追問。
        </p>
        <p>
          可以從3個維度分析，從建立專案初期到執行，到最後的轉化等角度分析並提出解決方案，並且提出統計數據作為案例背書。
        </p>
        <p>顯示身為專案負責人對於經手專案最佳化策略的把握。</p>

        <h4>WebP 圖片最佳化</h4>
        <p>
          產品頁面中常常存在大量的圖片內容,因此圖片的效能最佳化是一個瓶頸。
          除了使用傳統的圖片懶載入方法,還有 WebP
          格式取代方案。於可能存在潛在的相容性問題,所以會在取代圖片 進行 WebP
          圖片格式的相性偵測。此操作參考了社群的一貫做法。 利用 img 標籤載入一張 base64 的 WebP
          格式圖片,並將結果存入 localStorage 中防止重複判斷。如果該終端支援 WebP
          圖片格式,則再對圖片格式進行取代。 這個相容性偵測過程被封裝成 Promise
          化的通用介面,相關程式片段如下。
        </p>
        <pre><code class="language-js">
const supportWebp = () => new promise (resolve => {
  const image = new Image()
  image.onerror =() => resolve(false)
  image.onload = () => resolve(image.width ===1)
  image.src ='data:image/webp;base64, UklGRi QAAABXRUJOVIA4IBgAAAAWAEAAWAOJAQAA3AA/VUUAAA='
}).catch(()=>false)
        </code></pre>
        <p>
          這時試官常常會進一步關心專案收益情況。這需要面試者根據實際情況回答,舉例來說,實際上線時,對10%的流量進行了分組切分。5%為對照組,仍然採用傳統格式:另外5%為試驗组,進行
          WebP
          格式試驗。最後結果顯示收益非常有限。為此,進行了分析:認為出現近似零收益的原因是圖片服務的快取出現問題。由於新轉換的一批
          WebP
          格式圖片沒有被快取,因而效能出現問題。為了驗證猜想,決定繼續進行擴量試驗並觀察結果。果然,後續排除快取問題後,轉化提升了25%~30%
          左右。
        </p>
        <p>
          透過以上回答,如實說明了出現的非預期案例,並說明遇見問題時如何進行分析進而解決問題的一系列過程。這樣的回答能明確表現出確實做過該專案並進行了思考分析,最後落地。這種想法也更容易被面試官所接受。
        </p>
        <p>
          由此可以看出,效能最佳化其實並不難做,重要的是解決問題的想法,以及解決問題的過程中對專案的把控。這些內容稱之為「軟素質」。
        </p>
        <h4>隨選載入最佳化</h4>
        <p>
          如果面試官圍繞著剛才列舉的「資源包裝和向程式拆分(隨選載入)」方向提問,仍然會採用同樣的想法進行回答:
          接手專案後,發現歷史原有的資源包裝設定並不合理,嚴重影響了效能表現。因此,借助建置工具對資源進行了合併包裝。但是,需要注意的是,策略並不是大刀闊斧地進行資源合併,因為這様會讓
          bundle.js 的體積越來越大,所以需要進行逆向程式拆分。
        </p>
        <p>
          以實際頁面為例,當點擊播放按鈕後,頁面會出現視訊清
          單浮層(點擊視訊前後為同一頁面,類似單頁應用)。視訊列表浮層包含了捲動處理、视訊播放等多項複雜邏輯,因此並沒有對這個浮層的指令稿進行合併包裝,而是進行單獨拆分當使用者點擊浮層觸發按鈕後,再執
          行對這一部分指令稿的請求。
        </p>
        <p>
          對於專案方面涉及的效能最佳化,不僅需要做,還要用資料證明做法的合理性。同時,對使用者點擊觸發按鈕的機率進行了統計,發現進入頁面的使用者只有10%左右會點擊按鈕,進一步觸發視訊清單浮層。也就是說,大部分(90%)使用者並不會看到這一浮層,延遲隨選載入是有統計資料支援的。
        </p>
        <p>
          透過這個案例,發現效能最佳化其實是一個開放式問題,非常依賴實作。可根據上面的實例,結合自己的專案進行回答。
        </p>
        <p>
          雖然以上回答沒有涉及程式實現,但是能夠反映出面試者的專案意識,這在專案方面的效能最佳化實作中是非難能可貴的。上面建置工具進行「隨選載入」並不是使用熟的
          webpack
          工具鏈實現的，而是用公司內部封裝的專案化工具實現的。在幾年前,這樣的方案並不成熟,因此寫了一些隨選載入的外掛程式,配合自己的專案化工具使用。很多面試官都會對這方面的內容很有趣,可以將面試的問題延伸到
          FIS 和 webpack 的比較,以及專案化工具的設計等話題。
        </p>
        <p>
          專案方面有關的效能最佳化還包含圖片懶載入、雪碧圖、合理設定快取政策、使用 prefetch 或
          preload 進行預先載入、以 tree shaking 方法為主進行瘦身等內容。
        </p>
        <h4>瀏覽器動畫效能最佳化</h4>
        <ul>
          <li>
            一般來說,CSS3 比 JavaScript 實現為基礎動畫效率更高,因此會優先使用 CSS3
            實現動畫(這一點並非絕對)。
          </li>
          <li>在使用 CSS3 實現動畫時,要考慮開啟 GPU 加速(這一點也並不總是產生正向效果)。</li>
          <li>優先使用資源消耗最低的 transform 和 opacity 兩個屬性</li>
          <li>使用 will-change 屬性。</li>
          <li>獨立合成層,減少繪製區域。</li>
          <li>
            對於只能使用 JavaScript 實現動畫效果的情况,可以考慮使用 requestAnimationFrame 和
            requestIdleCallback API。
          </li>
          <li>批次進行樣式轉換,減少版面配置抖動。</li>
        </ul>

        <p>事實上,上面每個操作的背後都包含著很多基礎知識:</p>

        <ul>
          <li>如何了解 requestAnimationFrame 和 60fps?</li>
          <li>如何實現 requestAnimationFrame polyfill</li>
          <li>哪些操作會觸發瀏覽器 reflow(重排)或repaint(重繪)?</li>
          <li>對於列出的程式,如何進行最佳化?</li>
          <li>如何實現捲動時的節流、去抖動函數?</li>
        </ul>

        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
