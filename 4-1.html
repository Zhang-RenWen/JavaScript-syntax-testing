<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript-syntax-learning</title>
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</head>

<body>
    <nav>
        <h1>現代 Javascript 實務應用</h1>
    </nav>
    <main>
        <aside></aside>
        <section>
            <h2>4-1 Promise</h2>
            <h3 id="4-1-1">4-1-1 開始學習 Promise</h3>
            <p>
                瀏覽器所支援的新的 fetch API。個
                相當於簡化版的 XMLHttpRequest 。
                旨在提供使用者一個非常簡單的方式
                處理經常使用的案例 : 也就是以 HTTP 資源發送 GET 請求。
                基本的使用方式,可建立一個GET items HTTP 請求。
            </p>
            <pre><code class="language-js">
fetch('/items ')
 </code></pre>
            <p>他會對 /items 建立一個「開始並遺忘」的GET 請求，代表不管所送出的請求是否成成功，
                可以忽略回覆並續向下软行。fetch 方法會回傳一個Promise 物件。
                你可以於該Promise 物利用 .then 方法鏈結一個回呼函式，當/items 資源完成載入並接收到 response 物件便會執行指定的回呼函式
            </p>
            <pre><code class="language-js">
fetch('/items').then(response => {
  // 執行某些動作
})
 </code></pre>
            <p>
                以下的程式碼展示以 Promise 為基礎的 API
                利用他便可以將 fetch 於
                瀏覽器端完整際地實作。呼叫 fetch 函式會取得一個Promise 物件，
                就如事件一般你可以利用 .then 和 .catch 方法，該情境下應進行的動作進行繫結。
            </p>
            <pre><code class="language-js">
 const p = fetch('/items')
 p.then(res => {
  // 處理回應
 })

 p.catch(err => {
  // 處理錯誤
 })
 </code></pre>
            <p>.then 區塊中的動作是用以處理 Promise 請求完成後的情况，
                他在完成後提供一個履行完畢的值 ; 而 .catch 中的動作,
                是用以處理請求錯誤的情況,它會提供一個錯誤的原因。你也可以將錯誤的捕捉處理理於 .then 中、那麽上的程式碼則改寫如下。
            </p>
            <pre><code class="language-js">
const p = fetch('/items')
p.then(
res =>{
  // 處理回應
},
err => {
  // 處理错誤
}
 </code></pre>
            <p>
                一種替代方案是忽略對 .then(fulfillment,rejection) 的處理。
                這會與呼叫 .then 時，發生請求被拒絕的狀況但忽略不處理的情形類似。
                .then(null, rejection) 與 .catch(rejection) 在使用上有相同效果,如以下範例所示。
            </p>
            <pre><code class="language-js">
const p = fetch('/items')
p.then(res => {
  // 處理回應
})

p.then(null, err => {
  // 處理錯誤
})
 </code></pre>
            <div class="border-block">
                <h3>以Promise 作為回呼函式與事件的替代方案</h3>
                <p>
                    傳統上·JavaScript較為仰賴回呼函式·而非Promise和健結
                    (chaining)如果fetch函式需要一个回呼函式·那麼你象
                    加入一个函式,且此函式在fetch行完畢後必定會被教行·
                    在Node.js中典型的非同步程式流程慣例,將回呼函式的
                    的第一個參數保留給錯誤物件使用一即使錯誤不一定會發生一
                    在執行fetch的流程中,其餘的参數便可用以擷取非同步操作
                    的結果最常被使用的,是單一个資料参數的狀況·下面的程
                    式碼示範·若fetch具有一个回呼函式AP·它如何被操作
                    使用。

                </p>
                <pre><code class="language-js">
fetch('/items', (err, res) => {
if (err) {
    // 處理錯誤
} else {
   //處理回應
}
})
</code></pre>
                <p>
                    items資源取得之後,回呼函式才會被執行
                    fetch操作發生錯誤時。指令仍然為非同步執行且非阻塞式(nonBlocking)。注意在個模型下你只能夠指定一
                    個回呼,而此函式需負責處理所有的回覆情况;且仰賴使用者建立一種機制,可將各種不同面向的回應處理整合於一個回呼函式中。

                    除傳統的回呼函式之外,另一種 API 設計可選擇使用事件驅動的模型。在此情境下,自 fetch 回傳的物件必須能夠
                    為不同事件註冊回呼函式,為各種事件可能地繫結對應的事件處理器。就如將事件監聽器繫結至瀏覽器的DOM物件。當運作發生問題時,便喚起 error 事件;且當
                    值測到的錯誤也發生時對應的事件也會被喚醒。
                <pre><code class="language-js">
fetch('/items ')
.on('error', err => {
   // 處理錯誤
})
.on('data', res => {
  // 處理回應
}
</code></pre>
                <p>
                    對每一種事件類別結多個事件監聽器,可去除稍早前我們所討論於單一回呼函式集中處理所有的回應的議題。
                    然而,這也讓事件難以鏈結回呼函式,且當另一個非同步工作完成也會讓事件觸發;而這也就是 Promise 可以協助之處。此之外事件較適合用於一連串的值的處理,使得它在某些特殊的情況下不適合使用。
                </p>
            </div>
            <p>
                談到 Promise 物件,鏈結常是一個頭痛的問題。在以事件為
                基礎的 API 中, 藉由 .on 方法的使用可與事件處理器鏈結,並接著回到事件本體。但 Promise 則不同， .then .catch 方法每次均會回傳一個新的
                Promise 物件。這個觀念是很重要的,因為依據所鏈結的方法是 .then 或 .catch ，這會使程式較容易被理解推論。const 鏈結會產生完全不同的結果。
            </p>
            <div class="border-block">
                <h3>視覺化Promise:理解常見的觀念混淆問題</h3>
                <p>
                    .then和·catch方法每次均回傳一個新的 Promise 物件，
                    因此會建立了一個類似樹的資料結構。如果你具有名稱為 p1 的 Promise 物件,以及 p1.then所回傳的 p2 物件,那麼可將 p1 和 p2 視為連接至 p1.then
                    回應處理器的節點。這樣的
                    回應處理器會建立新的 Promise ,並連接至樹結構構中,作為它回應的 Promise 節點的子節點。

                    當鏈結 Promise 物件時，我們必瞭解 p1.then(r1).then(r2)
                    會建立兩個新的 p2 和 p3 的Promise 物件; 第二個回應處理,
                    r2,會於 p2 完成後被啟動; 而 r1 則是於 p1 完成後啟動。若是我們的敘述是以 p1.then(r1); p1.then(r2)的方式撰寫,那麼當 p1 完成時, r1 與 r2
                    均會啟動執行。比較上述兩情境,當 p1 完成而 p2 尚未完成時,就會發生不一致的狀況了。
                    釐清 Promise 物件的類樹狀結構的本質,是更進一步理解
                    Promise 物件運作的關鍵點。最後,我建立了一個線上的工具,
                    稱為 (<a href="https://bevacqua.github.io/promisees/">Promisees</a> ),你可以
                    使用他將所撰寫的 Promise 鏈結轉換為其所代表的樹狀結構圖
                </p>
            </div>

            <p>
                要建立一個 Promise 物件,需要傳遞一個解析器(resolver)至 Promise 中，解析器可決定該 Promise 如何與何時完成確認(settled); 它會藉由呼叫 resolve 方法將
                Promise 物件確認為已實現狀態;
                (fulfillment);或是呼叫 reject 方法將 Promise 物件確認為已拒絕狀態 (rejection) 在兩個函式之一被呼叫之前,他會處於一個暫停的
                (pending) 的狀態,且所有與之繫結的回應都不會被執行。以下的程式將示範如何從頭開始建立一個 Promise物件,但先已亂數的 方式將 Promise 物件確認為已實現或已拒絕的狀態。

            </p>
            <pre><code class="language-js">
new Promise(function (resolve, reject) {
    setTimeout(function () {
        if (Math.random() > 0.5) {
            resolve('random success')
        }else if {
            reject(new Error('random failure'))
    }, 1000)
})
</code></pre>
            <p>
                Promise 物件也可以利用 Promise.resolve 和 Promise.reject 建立。用這
                些方法建立 Promise 物件,可立即確認具有一個實現值(fulfillment value),或是具有一個拒絕原因的物件。
            </p>
            <pre><code class="language-js">
Promise
.resolve({result:123})
.then(data =>console.log(data.result))
//  123
</code></pre>
            <p>
                當一個 Promise 物件 p 為已實現狀態時,註冊於 p.then的回應便會被執行;當 p 為已拒絕狀態時,註冊於 p.catch的回應便會被執行。這些
                回應會依順序產生三種不的情況,根據它們的回傳值為一個值、一個 Promise 物件、一個 thenable 物件或利用throw 拋出錯誤。Thenable 物件被視為類 promise 的物件,可利用
                Promise.resolve 將它
                轉換為 Promise 物件。
            </p>
            <p>
                一個回應可能會回傳一個值,它藉由 .then 回傳一個已實現的 Promise 物件並附帶一實現值。在此狀下,
                Promise 物件可以被繫結，以將上一個 Promise 物件的實現值進行轉換,依此類推反覆進行,如下面程式碼所示
            </p>
            <pre><code class="language-js">
Promise
.resolve(2)
.then(x=>x*7)
.then(x=>x-3)
.then(x=> console.log(x))
// 11
            </code></pre>
            <p>
                一個回應也會回傳一個 Promise 物件,對比上一個範例程式,下面程式碼等待呼叫第一個 .then 所回傳的物件 , 須至它的回應已實現後，才能夠取得;
                因為 setTimeout 的函式呼叫,需要大約 2 秒鐘後才
                會確認為已實現的狀態。
            </p>
            <pre><code class="language-js">
Promise
.resolve(2)
.then(x => new Promise(function (resolve) {
setTimeout(()=> resolve(x*1000),x*1000)
}))
.then(x =console.log(x)
// 2000
            </code></pre>
            <p>
                一個回應也可能以 throw 拋出錯,會使 .then 所回傳的Promise 物件成為已拒絕狀態，並接著進入 .catch 的分支區塊 , 以 error 物件作為拒絕的原因。
                以下程式範例展示如何於 fetch 操作加上一個已實現的回應 ; 當 fetch 為已實現狀態時,在回應中會抛出一個錯誤,並産生一個已拒絕的回應，繫結於執行 .then 後所回傳的 Promise 物件上。
            </p>
            <pre><code class="language-js">
const p = fetch('/items')
.then(res => { throw new Error('unexpectedly')})
.catch(err => console.error(err))
            </code></pre>


            <h3 id="4-1-2">4-1-2 Promise 物件的再開始和連結</h3>
            <P>

            </P>

        </section>
    </main>
</body>
<script src="./menu.js"></script>

</html>