<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript-syntax-learning</title>
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link
      rel="stylesheet"
      href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css"
    />
    <link rel="stylesheet" href="./css/main.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <nav>
      <h1>現代 Javascript 實務應用</h1>
    </nav>
    <main>
      <aside></aside>
      <section>
        <h2>3-1 類別、符號、物件和修飾器</h2>
        <h3>3-1-1 類別基本元素</h3>
        <p>
          下面的程式範例表示一个水果,可以利用一個建構子函式並在原型中加
          入一系列的方法。建構子函式需要傳遞name 和 caries 參數,來表示
          該水果的名稱以及卡路里的總量；建構子中水果切片數量,以 pieces 紀錄
          ,預設為1。而在此處定義了一個 .chop 方法,可將水果切出另外一 片;一個
          .bite 方法需要傳遞 person 參數,表示一個人吃掉了一片水
          果,並計算取得的卡路里數量,也就是將水果的剩餘的卡路里數除以剩
          餘的水果片數。
        </p>
        <pre><code class="language-js">
            function Fruit(name, calories) {
            this.name = name
            this.calories = calories
            this.pieces = 1
            }

            Fruit.prototype.chop = function () {
            this.pieces++
            
        }
            Fruit.prototype.bite = function (person) {
            if (this.pieces &lt; 1) {
            return
            }
            const calories = this.calories / this.pieces
            person.satiety += calories
            this.calories -= calories
            this.pieces--
        }
        </code></pre>
        <p>
          非常簡單的範例,但有幾項要點需注意。這裡我們看到有一個建構子函
          式,它需要幾個參數,也定義了一些方法和幾項特性。以下的程式碼示
          範如何建立一個 Fruit 和一個 person， 這個人會將水果切為四片並吃掉
          其中三片。
        </p>
        <pre><code class="language-js">
            const person = { satiety: 0 }  
            const apple = new Fruit('apple', 140)
            apple.chop()
            apple.chop()
            apple.chop()
            apple.bite(person)
            apple.bite(person)
            apple.bite(person)
            console.log(person.satiety)
            // 105
            console.log(apple.pieces)
            // 1
            console.log(apple.calories)
            // 35
        </code></pre>
        <p>
          若是使用 class 語法描述此類別，如下案例所示,constructor函式被 宣告為
          Fruit 類別的顯性員，而接下來的方法描述則遵循物件實字的
          定義語法。當我們比較 class 語法和以原型為基礎的語法時,你會發現
          減少許多重複性的樣板程式碼,如 Fruit.prototype 都可以省略了。整
          個類別的宣告定義都描述於 class 區塊中,也可幫助讀者瞭解這段程式
          的作用範圍，使類別的目的更為清楚。最後,有一個顯性的建構子函式 作為
          Fruit 類別的成員函式,比起既有的方式,可讓 class 語法更為明 瞭易懂。
        </p>
        <pre><code class="language-js">
class Fruit {
    constructor(name, calories) {
    this.name = name
    this.calories = calories
    this.pieces = 1
    }

    chop() {
        this.pieces++
    }

    bite(person) {
        if (this.pieces &lt; 1) {
            return
        }
        const calories = this.calories / this.pieces
        person.satiety += calories
        this.calories -= calories
        this.pieces--
    }
}
        </code></pre>
        <p>
          還有一個你可能未注意到的細節,也就是在 Fruit 類別中各個方法的
          定義之間並未使用逗號分隔。這並不是編輯排版上遺漏的錯誤，而是 class
          語法的一部分。這個物件與類別定義上的差異,可以避免我們描
          述二者時產生混淆的錯誤,且讓類別語法更適合在未來語法上的改善強 化,例如
          公開(public) 和 私有(private) 的定義。
        </p>
        <p>
          值得注意的是,類別的宣告是無法提升至最高作用域,與函式宣告不
          同。這表的意義是,在編譯器尚未抵達和執行類別的宣告之前,你將
          無法建立或存取類別。
        </p>
        <pre><code class="language-js">
new Person()// ReferenceError:Person 未被定義
class Person {}
        </code></pre>
        <p>
          除了類別宣告的語法外,類別也能夠以運算式的方式進行宣告,就像
          是函式宣告和函式運算式一般。使用 class 運算式時,你也可以省略對
          它的命名,如下範例所示。
        </p>
        <pre><code class="language-js">
const Person = class {
    constructor(name) {
        this.name = name
    }
}
        </code></pre>
        <p>
          類別運算式可以很容易地自函式回傳,能夠以最少的成本建立類別製
          造工廠。在下面的範例中,我們會在一個箭頭函式中動態地建立一個 JakePerson
          類別,箭頭函式需要傳遞一名稱為 name 的參數,並利用 super()
          函式將它傳遞至父類別 Person 的建構子中。
        </p>
        <pre><code class="language-js">
const createPersonClass = name => class extends Person { 
    constructor() {
    super(name)
    }
}
const JakePerson = createPersonClass('Jake')
const jake = new JakePerson()
console.log(jake) // Person {name: 'Jake'}
        </code></pre>

        <h3>3-1-2 類別中的特性與方法</h3>
        <p>
          值得注意的是 constructor 方法的宣告在 class 的定義中是選用,非
          絕對必要。以下的程式碼呈現一個有效的 class 宣告,和一個相同名稱
          的建構子函式,互相比較其中的異同。
        </p>
        <pre><code class="language-js">
          class Fruit {}
          function Fruit() {}
        </code></pre>
        <p>
          傳遞至 new Log 的引數可視為 Log 類別建構子函式的參數，如下所示。
          你可以用這些參數來初始化類別的實體。
        </p>
        <pre><code class="language-js">
class Log {
  constructor(...args) {
    console.log(args)
  }
}

new Log('a', 'b', 'c') // ['a' 'b' 'c']
        </code></pre>
        <p>
          下方的範例顯示,在類別的建構子中,可為每一個實體建立和初始化 count
          特性。get next方法的宣告,表示所定義的Counter類別的實
          體,將具有一個名稱為 next 的特性;當存取這個特性時,其值就是呼叫
          與它同名的方法取得。
        </p>
        <pre><code class="language-js">
          class Counter {
            constructor(start) {
              this.count = start
            }
            get next() {
              return this.count++
            }
          }
        </code></pre>
        <p>
          在此案例中,你可以如下程式碼的方式使用 Counter 類別。每當.next
          特性被存取時,計數器便會增加1。這樣的運用方式,會比定義 get
          特性操作器(property accessor )
          的函式較佳;且特性操作器需注意不被過度濫用,否則會令人感到困惑。
        </p>
        <pre><code class="language-js">
              const counter = new Counter(2)
              console.log(counter.next)
              // 2
              console.log(counter.next)
              // 3
              console.log(counter.next)
              // 4
             </code></pre>
        <p>
          若與設定器( setter )一同搭配，擷取器便可以作為物件和其下的資料儲存
          區的橋梁。參考以下範例，我們定義了一個類別,可透過指定的儲存區鍵 key
          來儲存和自 localStorage 擷取資料。
        </p>
        <pre><code class="language-js">
class LocalStorage {
  constructor(key) {
    this.key = key
  }
  
  get data() {
    return JSON.parse(localStorage.getItem(this.key))
  }
  
  set data(data) {
    localStorage.setItem(this.key, JSON.stringify(data))
  }
}
            </code></pre>
        <p>
          接著,你可以運用 LocalStorage 類別,如下個範例所示。任何指 定於予
          ls.data 的值均會被轉存為 JSON 物件的字串格式,並儲存於 LocalStorage
          。後續當需要存取特性時,就利用相同的儲存鍵 key 來擷
          取出之前所儲存的資料,以 JSON 格式剖析為一個物件並回傳。
        </p>
        <pre><code class="language-js">
          const ls = new LocalStorage('groceries')
          ls.data = ['apples', 'bananas', 'grapes']
          console.log(ls.data)  // ['apples', 'bananas', 'grapes']
        </code></pre>
        <p>
          除了擷取器 (getter) 和設定器(setter)外,也可以定義一些方法，
          就如稍早我們建立的 Fruit 類別一樣。下面的程式範例,示範建立一個 Person
          類 別,他以之前討論過的方式,食用 Fruit 實體。接著我們會
          建立一個水果和一個人員的實體,並使人員執行吃水果。
          最後,人員吃掉了整顆水果,並達到 40 的飽足度。
        </p>
        <pre><code class="language-js">
class Person {
  constructor() {
    this.satiety = 0
  }
  
  eat(fruit) {
    while (fruit.pieces &gt; 0) {
      fruit.bite(this) 
    }
  }
}

const plum = new Fruit('plum', 40)
const person = new Person()
person.eat(plum)
console.log(person.satiety) // 40
        </code></pre>
        <p>
          有時會需要在類別階層加入一些静態方法,而非在實體階層使用成員方 法。在
          ES6 之前的語法,實體成員必須明確地加入至原型鍊,而靜態方
          法必須直接於建構子中定義。
        </p>
        <pre><code class="language-js">
          function Person() {
            this.hunger = 100
          }
       
          Person.prototype.eat = function () {
            this.hunger--
          }
        
          Person.isPerson = function (person) {
            return person instanceof Person
          }
        </code></pre>
        <p>
          JavaScript 類別可使用 static 關鍵字定義靜態方法,如:Person.isPerson
          ，就如於方法前使用 get 或 set 關鍵字，以描述該方法為擷取器或設定器。
          下範例定義一個 MathHelper 類別,其中包含一個靜態方法 sum, 他會藉由使用
          Array#reduce 方法,計算所有傳遞至函式中的數值總和。
        </p>
        <pre><code class="language-js">
class MathHelper {
  static sum(...numbers) {
    return numbers.reduce((a, b) => a + b)
  }
}
console.log(MathHelper.sum(1,2,3,4,5)) // 15
        </code></pre>
        <p>
          值得一提的是，你也可以定義靜態的特性操作器,例如: 擷取器 或
          設定器(static get、static set)。當為護一些類別裡全域的設定狀態、
          或在單例模式 (singleton pattern) 下使用類别時,這些特性操作器
          多少都可以派上用場。當然，或許你還是習慣使用舊的 JavaScript 物件
          ,而非操作這些你未曾使用過、或僅使用過少數幾次的方式建立類別。
          無論何種方式,這就是 JavaScript ,一種高度彈性的語言。
        </p>
        <h3>3-1-3 延伸 JavaScript 類別</h3>
        <p>
          你可使用單純的 JavaScript 自 Fruit 類別延伸出新類別,但在閱讀完下面程
          式碼後,你會注意到,要宣告一個子類別會涉及到一些艱深的知識， 例如:
          Parent.call(this),可將參數傳遞至父類別中,以為子類別進行初始化，
          ,並將子類別的原型設定為父類別原型的一個實體。你可以在
          網路上找到一堆有關原型承的資訊,在此我們便不會深入探討原型繼承的一些細節原理。
        </p>
        <pre><code class="language-js">
function Banana() {
  Fruit.call(this, 'banana', 105)
}
Banana.prototype = Object.create(Fruit.prototype)
Banana.prototype.slice = function (){
  this.pieces = 12
}
                </code></pre>
        <p>
          此程式碼僅有一個地方需要注意,就是Object.create 只能夠於 ES5 中 使用;
          JavaScript 開發人員為了解決原型繼承的議題,已經發展了許多函
          式庫提供使用。其中一個例子就是 Node.js 中 util.inherits,若除去
          一些舊版支援需使用 Object.create 的因素,這會是較佳的方法。
        </p>
        <pre><code class="language-js">
const util = require('util')
function Banana() {
  Fruit.call(this, 'banana', 105)
}
util.inherits(Banana, Fruit)
Banana.prototype.slice = function () {
  this.pieces = 12
}
                </code></pre>
        <p>
          操作 Banana 建構子的方式與操作 Fruit 大致相同,除了香蕉類別具有已事先
          指定的 name 水果名稱和卡路里總量;且多了一個 slice 方法，可用它將香蕉
          切為12片。以下的程式碼展示一位人員取用香蕉的操作描述。
        </p>
        <pre><code class="language-js">
const person =  {satiety: 0}
const banana = new Banana()
banana.slice()
banana.bite(person)
console.log(person.satiety) // 8.75
console.log(banana.pieces) // 11
console.log(banana.calories) // 96.25
                </code></pre>
        <p>
          類別整併了原型繼承,並逐漸被廣泛運用,直到近期出現數種函式庫，
          嘗試提供更簡化 JavaScript 的原型承機制。 Fruit
          類別也適合使用於繼承。在以下的程式碼,我們建立一個 Banana 類別
          ，他延伸自 Fruit 類別。在此處，程式語法就可以清楚地表達我們的
          目的,完全不需瞭解原型繼承的觀念也能夠得到我們所需要的結果。
          當我們需要將參數向上傳遞至父類別的 Fruit 建構子時,可以利用 super。
          關鍵字 super 可用呼叫父類別的函式,例如:super.chop,並不是只
          能呼叫父類別的建構子而已。
        </p>
        <pre><code class="language-js">
class Banana extends Fruit {
  constructor() {
    super('banana', 105)
  }
  
  slice() {
    this.pieces = 12
  }
}
                </code></pre>
        <p>
          即便關鍵字 class 是靜態的,我們仍然可以在宣告類别時,發揮 JavaScript
          極富彈性的特性。任何回傳一個建構子函式的運算式都可以 提供給 extends
          使用。舉例說,我們可以建立一個建構子函式工廠 (constructor function
          factory),並以他作為基礎類別。 以下程式碼包含一個 createJuicyFruit
          函式, 允許傳入水果的名稱和卡路里數量,並透過呼叫 super 傳給父類別
          Fruit。接著,我們會建立 一個 plum 類別,它會繼承自中繼的 JuicyFruit
          類別。
        </p>
        <pre><code class="language-js">
const createJuicyFruit = (...params) =>
class JuicyFruit extends Fruit {
  constructor() {
    this.juice = 0
    super(...params)
  }
  
  squeeze() {
    if (this.calories &lt;= 0) {
      return
    }
    
    this.calories -= 10
    this.juice += 3
  }
}
class Plum extends createJuicyFruit('plum', 30) {}
                </code></pre>
      </section>
    </main>
  </body>
  <script src="./menu.js"></script>
</html>
