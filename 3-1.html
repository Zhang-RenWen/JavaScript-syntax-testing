<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript-syntax-learning</title>
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link
      rel="stylesheet"
      href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css"
    />
    <link rel="stylesheet" href="./css/main.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <nav>
      <h1>現代 Javascript 實務應用</h1>
    </nav>
    <main>
      <aside></aside>
      <section>
        <h2>3-1 類別、符號、物件和修飾器</h2>
        <h3>3-1-1 類別基本元素</h3>
        <p>
          下面的程式範例表示一个水果,可以利用一個建構子函式並在原型中加
          入一系列的方法。建構子函式需要傳遞name 和 caries 參數,來表示
          該水果的名稱以及卡路里的總量；建構子中水果切片數量,以 pieces 紀錄
          ,預設為1。而在此處定義了一個 .chop 方法,可將水果切出另外一 片;一個
          .bite 方法需要傳遞 person 參數,表示一個人吃掉了一片水
          果,並計算取得的卡路里數量,也就是將水果的剩餘的卡路里數除以剩
          餘的水果片數。
        </p>
        <pre><code class="language-js">
            function Fruit(name, calories) {
            this.name = name
            this.calories = calories
            this.pieces = 1
            }

            Fruit.prototype.chop = function () {
            this.pieces++
            
        }
            Fruit.prototype.bite = function (person) {
            if (this.pieces &lt; 1) {
            return
            }
            const calories = this.calories / this.pieces
            person.satiety += calories
            this.calories -= calories
            this.pieces--
        }
        </code></pre>
        <p>
          非常簡單的範例,但有幾項要點需注意。這裡我們看到有一個建構子函
          式,它需要幾個參數,也定義了一些方法和幾項特性。以下的程式碼示
          範如何建立一個 Fruit 和一個 person， 這個人會將水果切為四片並吃掉
          其中三片。
        </p>
        <pre><code class="language-js">
            const person = { satiety: 0 }  
            const apple = new Fruit('apple', 140)
            apple.chop()
            apple.chop()
            apple.chop()
            apple.bite(person)
            apple.bite(person)
            apple.bite(person)
            console.log(person.satiety)
            // 105
            console.log(apple.pieces)
            // 1
            console.log(apple.calories)
            // 35
        </code></pre>
        <p>
          若是使用 class 語法描述此類別，如下案例所示,constructor函式被 宣告為
          Fruit 類別的顯性員，而接下來的方法描述則遵循物件實字的
          定義語法。當我們比較 class 語法和以原型為基礎的語法時,你會發現
          減少許多重複性的樣板程式碼,如 Fruit.prototype 都可以省略了。整
          個類別的宣告定義都描述於 class 區塊中,也可幫助讀者瞭解這段程式
          的作用範圍，使類別的目的更為清楚。最後,有一個顯性的建構子函式 作為
          Fruit 類別的成員函式,比起既有的方式,可讓 class 語法更為明 瞭易懂。
        </p>
        <pre><code class="language-js">
class Fruit {
    constructor(name, calories) {
    this.name = name
    this.calories = calories
    this.pieces = 1
    }

    chop() {
        this.pieces++
    }

    bite(person) {
        if (this.pieces &lt; 1) {
            return
        }
        const calories = this.calories / this.pieces
        person.satiety += calories
        this.calories -= calories
        this.pieces--
    }
}
        </code></pre>
        <p>
          還有一個你可能未注意到的細節,也就是在 Fruit 類別中各個方法的
          定義之間並未使用逗號分隔。這並不是編輯排版上遺漏的錯誤，而是 class
          語法的一部分。這個物件與類別定義上的差異,可以避免我們描
          述二者時產生混淆的錯誤,且讓類別語法更適合在未來語法上的改善強 化,例如
          公開(public) 和 私有(private) 的定義。
        </p>
        <p>
          值得注意的是,類別的宣告是無法提升至最高作用域,與函式宣告不
          同。這表的意義是,在編譯器尚未抵達和執行類別的宣告之前,你將
          無法建立或存取類別。
        </p>
        <pre><code class="language-js">
new Person()// ReferenceError:Person 未被定義
class Person {}
        </code></pre>
        <p>
          除了類別宣告的語法外,類別也能夠以運算式的方式進行宣告,就像
          是函式宣告和函式運算式一般。使用 class 運算式時,你也可以省略對
          它的命名,如下範例所示。
        </p>
        <pre><code class="language-js">
const Person = class {
    constructor(name) {
        this.name = name
    }
}
        </code></pre>
        <p>
          類別運算式可以很容易地自函式回傳,能夠以最少的成本建立類別製
          造工廠。在下面的範例中,我們會在一個箭頭函式中動態地建立一個 JakePerson
          類別,箭頭函式需要傳遞一名稱為 name 的參數,並利用 super()
          函式將它傳遞至父類別 Person 的建構子中。
        </p>
        <pre><code class="language-js">
const createPersonClass = name => class extends Person { 
    constructor() {
    super(name)
    }
}
const JakePerson = createPersonClass('Jake')
const jake = new JakePerson()
console.log(jake) // Person {name: 'Jake'}
        </code></pre>

        <h3>3-1-2 類別中的特性與方法</h3>
        <p>
          值得注意的是constructor方法的宣告在class的定義中選用,非
          絕對必要。以下的程式碼呈現一個有效的class宣告,和一個相同名稱
          的建構子函式,互相比較其中的異同。
        </p>
        <pre><code class="language-js">
          class Fruit f
          function Fruit() [
        </code></pre>
        <p>
          傳遞至newLg的數可為類建構子函式的數如下所
          你可以用這些參數來初始化類別的實體。
        </p>
        <pre><code class="language-js">
class Log f
constructor(...args) {
console.1og(args)
new Log('a', 'b', 'c')
// ['a' 'b' 'c']
        </code></pre>
        <p>
          下方的範例顯示,在类別的建構子中,可為每一個實體建立和初始化
          count特性getnext方法的宣告,表示所定義的Counter類別的實
          體,將具有一個名稱為next的性;存取個特性,其值就是呼 與它同名的方法取得。
        </p>
        <pre><code class="language-js">
          class Counter f
          constructor(start) [
          this.count = start
          get next() [
          return this.count+t
        </code></pre>
        <p>
          在此案例中,你可以如下程式碼的方式使用counter別。每当.ex
          特性被存取時數器便會增加1。樣的運用方式,比定義get特性 #器(property
          accessr的式較佳特性作器需注意不 濫用,否則會令人感到困惑。
        </p>
        <pre><code class="language-js">

              const counter = new counter(2)
              console.10g(counter.next)
              // 2
              console.10g(counter.next)
              // 3
              console.10g(counter.next)
              // 4
             </code></pre>
        <p>
          設定器(setter一搭配器便可以作為物件和
          區的橋梁。參考以下範例、我們定義了一個類別,可透 存區鍵ke儲c資料
        </p>
        <pre><code class="language-js">
class LocalStorage f
constructor(key) [
this.key = key
get data() [
return JSON.parse(localStorage.getItem(this.key))
set data(data) f
localStorage.setItem(this.key, JSON.stringify(data))
            </code></pre>
        <p>
          接著,你可以運用localsrae別,如下個範例所示。任何
          定子1s.data的值均會被轉存為JSON物件的字电格式,並儲存
          localstorage。後續當需要存取特性時,就利用相同的儲存鍵key
          取出之前所儲存的資料,以JSON格式剖析為一個物件並回傳
        </p>
        <pre><code class="language-js">
          const 1s = new LocalStorage(' groceries')
ls.data = ['apples', 'bananas', 'grapes']
console.log(1s.data)
// ['apples', 'bananas', 'grapes']
        </code></pre>
        <p>
          除了擷取器(getter和設定器(setter)外,也可以定義一些方法
          虎如稍早我們建立的Fru別一樣。下的程式範例,示範建
          別,他以之前討論過的方式,食用Fu實
          建立一個水果和一個人員的實體,並使人員執行吃水果
          後,人員吃掉了整顆水果,並達到40的飽足度。
        </p>
        <pre><code class="language-js">
class Person f
constructor() [
this,satiety = 0
eat(fruit) [
while (fruit.pieces > 0) [
fruit.bite(this)
const plum = new Fruit('plum', 40)
const person = new Person()
person.eat(plum)
console.1og(person.satiety)
// 40
        </code></pre>
        <p>
          有時會需要在類別階層加入一些静態方法,而非在實體階層使用成員方
          法在ES6之前的语法,体成員必須明確地加入至原型,而靜態方
          法必須直接於建構子中定義。
        </p>
        <pre><code class="language-js">
          function Person() [
          this.hunger = 100
          Person.prototype.eat = function () f
          this.hunger--
          Person.isPerson = function (person) [
          return person instanceof Person
        </code></pre>
        <p>
          JavaScript類別可使用static關鍵字定義靜態方法,如:Person
          isperson就如於方法前使用get或se關鍵描該方法為 取器或設定器。
          下範例定義一個t,其包一個靜方法 藉使用Array#reduce
          方法,算所有傳遞至函式中的數值總和。
        </p>
        <pre><code class="language-js">
class MathHelper f
static sum(...numbers) f
return numbers.reduce((a, b) => a + b)
console.10g(MathHelper.sum(1,2,3,4,5))
// 15
        </code></pre>
        <p>
          植得提的你也可以義靜態的特性操作器,例如:
          設定器(staticgetstticset)護一些類別裡全域
          #、或在單例模式(singleto使類别時,些特性
          多少都可以派上用場。當然、或許你還是習慣使用的Java
          ,而非操作些你未曾使用過、或僅使用過少數次的方式建立
          無論何種方式,這就是Javacript,一種高度彈性的
        </p>
      </section>
    </main>
  </body>
  <script src="./menu.js"></script>
</html>
