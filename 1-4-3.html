<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-4-3">1-4-3 架構與效能: React & Vue3</h2>
        <h3>架構的效能到底指什麼</h3>
        <p>
          大部分應用的複雜度並不會對效能和產品體驗組成挑戰。現代化的架構憑藉高效的虛擬 DOM diff
          演算法、響應式理念及架構內部引擎,已經做得較為完美了,一般專案需求不會對效能產生太大的壓力。
        </p>
        <p>
          但是對於一些極其複雜的需求,效能最佳化問題是無法回避的。如果是圖形處理應用、DNA檢測實驗應用、豐富文字編輯或功能豐用的表單型應用,則很容易觸碰到效能瓶頸。同樣,作為架構的使用者,也需要對效能最佳化有所了解,這對了解架構本身也有很大的幫助。
        </p>
        <p>
          前端開發自然離不開瀏覽器,而效能最佳化大都在和瀏覽器進行處理,頁面每一幀的變化都是由瀏覽器繪製出來的,並且這個繪製額示器的更新頻率受限於顯示器的更新頻率,因此一個重要的效能資料指標是每秒
          60 幀的繪製頻率。這樣進行簡單的換算之後,每一幀只有 16.6ms 繪製時間。
        </p>
        <p>
          一個應用對使用者的互動回應處理過慢,則需要花費很長的時間來計算更新資料,這就會造成應用緩慢、效能不佳的問題,使得使用者體驗極差。對架構來說,以
          react 為例,開發者不需要額外關注 DOM 層面的操作,因為 React 透過維護虛擬 DOM 並使用其高效的
          diff 演算法,就可以決策出每次更新的最小化 DOM 合併操作。實際上,使用 React
          能做到的效能最佳化，使用純原生的 JavaScript 也能做到,甚至做得更好。只不過透過 React
          進行統一處理後,可以大幅節省開發成本,同時降低應用效能對開發者最佳化技能的依賴。
        </p>
        <p>
          因此,對於現代架構在效能方的最佳化,除了可以想辦法縮減本身的套件體積,主要在於架構本身執行時期對
          DOM操作的合理性及本身引擎計算的高效性等方面的最佳化。
        </p>
        <h3>React 的虛擬 DOM diff</h3>
        <p>React 主要透過以下幾種方式來確保虛擬 DOM diff 演算法更新都能夠高效。</p>
        <ul>
          <li>使用高效的 diff 演算法。</li>
          <li>進行 batch 操作。</li>
          <li>摒棄髒檢測更新方式。</li>
        </ul>
        <p>
          一個元件使用 setState 方法時， React
          都會認為該元件變「髒」了，進而觸發元件本身的重新繪製(re-render)時,因為 React
          始終維護兩套虛擬 DOM,其中一套是更新後的虛擬 DOM,另一套是前一個狀態的虛擬
          DOM，所以可以透過對這兩套虛擬 DOM 執行 diff
          演算法,找到需要變化的最小單元集，然後把這個最小單元集應用在真實的 DOM 中。
        </p>
        <p>
          透過 diff 演算法找到這個最小單元集後,React 採用啟發式的想法進行了一些假設,將兩棵 DOM
          樹之間的差異尋找成本由 O(n³) 縮減到 O(n)。
        </p>
        <p>說到這裡,你一定很想知道 React 進行了哪些大膽假設，下兩點便是。</p>
        <ul>
          <li>對 DOM 節點跨層級移動的情況忽略不計。</li>
          <li>
            擁有相同類型的兩個元件產生相似的樹狀結構,擁有不同類型的兩個元件產生不同的樹狀結構。
          </li>
        </ul>
        <p>根據這些假設, React 採取的策略如下。</p>
        <ul>
          <li>React 對元件樹進行分層比較,兩棵樹只會對同一層级的節進行比較。</li>
          <li>
            當對同一層級的節點進行比較時,對於不同的元件類型,直接將整個元件取代為更新後的元件。對於下圖所示的元件結構,如果子元件
            B 和 H 類型同時發生化,那麼當查到B 元件時,直接將其取代為元件可以減少不必要的資源消耗。
          </li>
        </ul>
        <ul>
          <li>
            當對同一層級的節進行比較時,對於相同的元件類型,如果元件的 state或props
            發生變化,直接重新繪製元件本身。開發者可以嘗試使用 shouldComponentUpdate
            生命週期函數來避開不必要的繪製。
          </li>
          <li>當對同一層級節點進行比較時,開發者可以使用 key 屬性來宣吿同一層級節點的更新方式。</li>
        </ul>
        <p>
          另外，setState 方法會引發「蝴蝶效應」,並透過創新的diff
          演算法找到需要更新的最小單元集,但是這些變更並不一定立即同步生效。實際上, React 會執行
          setState
          的合併操作,通俗地講就是「積攢歸併」一批變化後,再統一進行更新。顯然,這是出於對效能的考慮。
        </p>
        <h3>提升 React 應用效能的建議</h3>
        <p>React 繪製真實的 DOM 節點的過程由兩個主要過程組成。</p>
        <ul>
          <li>對 React 內部維的虛擬 DOM 進行更新。</li>
          <li>比較前後兩個虛擬 DOM,並將 diff 所得結果應用於真實的 DOM 中。</li>
        </ul>
        <p>這兩步極其關鍵。設想一下,如果虛擬 DOM ,那麼重新 繪製勢必會很耗時。</p>
        <h4>大幅地減少重新繪製</h4>
        <p>
          為了提升 React
          應用效能,首先想到的就是大幅地避開不必要的重新繪製。但是,當狀態發生變化時,重新繪製是 react
          內部的預設行為,如何確保不必要的繪製呢?
        </p>
        <p>
          最先想到的解決方案一定是使用 shouldComponentUpdate
          生命週期函數,它旨在比較前後狀態(state/props)是否出現了變更,根據是否變更來決定元件是否需要重新繪製。
        </p>
        <p>實際上,開發者可以透過很多方式給 react 送「不需要繪製」的訊號。</p>
        <p>
          舉例來說,對於無狀態元件傳回同一個 element 實例的情况,如果每次執行 render 方法都傳回相同的
          element 實例,React 會認為元件並沒有發生變化,程式如下所示。
        </p>
        <pre><code class="language-js">
class MyComponent extends Component {
  text = '';
  renderedElement = null;
  _render() {
    return &lt;div&gt;{this.props.text}&lt;/div&gt;
  }
  render() {
    if (!this.renderedElement || this.props.text !== this.text) {
      this.text = this.props.text;
      this.renderedElement = _render();
    }
    return this.renderedElement;
  }
  // ...
}
        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
