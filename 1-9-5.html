<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-9-5">1-9-5 Predicates Logic</h2>
        <h3>Universal Instantiation(UI)</h3>
        <p>
          如果一個命題對於所有元素 𝑥 都成立，那麼我們可以推導出這個命題對於某個特定的元素 𝑎 也成立。
        </p>
        <h5>命題：</h5>
        <p>所有人都是凡人。</p>
        <p>∀x(人(x)→凡人(x))</p>
        <h5>推導：</h5>
        <p>蘇格拉底是人。</p>
        <p>人(蘇格拉底)</p>
        <h5>結論：</h5>
        <p>蘇格拉底是凡人。</p>
        <p>凡人(蘇格拉底)</p>
        <h4>證明過程</h4>
        <ol>
          <li>
            <strong>普遍命題：</strong>
            假設我們知道 ∀𝑥 ( 人 ( 𝑥 ) → 凡人 ( 𝑥 ) ) 為真，這意味著對於每個 𝑥 ，如果 𝑥 是人，那麼 𝑥
            也是凡人。
          </li>
          <li>
            <strong>特例：</strong>
            我們知道蘇格拉底是人，即 人 ( 蘇格拉底 ) 。
          </li>
          <li>
            <strong>應用普遍例証：</strong>
            從 ∀ 𝑥   ( 人 ( 𝑥 ) → 凡人 ( 𝑥 ) ) 中，我們可以推導出 ( 人 ( 蘇格拉底 ) → 凡人 (
            蘇格拉底 ) ) 。
          </li>
          <li>
            <strong>結論：</strong>
            由於 人 ( 蘇格拉底 ) 為真，因此 凡人 ( 蘇格拉底 ) 也為真。
          </li>
        </ol>
        <h4>更加複雜的案例</h4>
        <p>證明以下邏輯陳述是 valid：</p>
        <p>(∀x)[(M(x)→S(x))]∧M(s)→S(s)</p>
        <p>
          這表示：如果對所有 𝑥 ， 𝑀 ( 𝑥 ) → 𝑆 ( 𝑥 ) 成立，且 𝑀 ( 𝑠 ) 為真，那麼 𝑆 ( 𝑠 ) 必定為真。
        </p>
        <h5>證明過程</h5>
        <ol>
          <li>假設 ∀ 𝑥 ( 𝑀 ( 𝑥 ) → 𝑆 ( 𝑥 ) ) 為真</li>
          <li>假設 𝑀 ( 𝑠 ) 為真</li>
          <li>
            <strong>根據 UI</strong>
            :由於 ∀ 𝑥 ( 𝑀 ( 𝑥 ) → 𝑆 ( 𝑥 ) )表示對所有 𝑥 這個命題都成立，我們可以對特定的 𝑠
            使用這個普遍命題。因此，我們可以推論出：M(s)→S(s)也成立。
          </li>
          <li>
            <strong>根據 Modus Ponens：</strong>
            因為 M(s) 為真，根據 M(s)→S(s)，得 S(s) 為真
          </li>
        </ol>
        <h3>Existential Instantiation(EI)</h3>
        <p>
          如果有一個命題對於某些元素 𝑥 成立，那麼我們可以引入一個特定的符號 𝑐
          來表示這個存在的個體，並推導出這個命題對於 𝑐 也成立。
        </p>
        <p>形式化表示為：</p>
        <p>(∃𝑥) P(𝑥)→P(c)</p>
        <p>
          這意味著，如果 (∃ 𝑥) 𝑃 ( 𝑥 ) 為真，那麼我們可以說 𝑃 ( 𝑐 ) 為真，其中 𝑐 是某個特定的個體。
        </p>
        <h5>命題：</h5>
        <p>存在一個人是數學家。</p>
        <p>(∃𝑥) M(𝑥)</p>
        <h5>推導：</h5>
        <p>可以引入一個特定的符號 𝑎 表示這個存在的數學家，因此：M(𝑎)</p>
        <h4>複雜的案例</h4>
        <p>證明以下邏輯陳述是 valid：</p>
        <p>(∀𝑥)[(P(𝑥)→Q(𝑥))]∧ (∃y)𝑃(y) → Q(a)</p>
        <p>
          這表示：如果對所有 𝑥 ， 𝑃 ( 𝑥 ) → 𝑄 ( 𝑥 ) 成立，且存在某個 𝑦 使得 𝑃 ( 𝑦 ) 為真，那麼 𝑄 ( 𝑎
          ) 為真。
        </p>
        <h5>證明過程</h5>
        <ol>
          <li>
            假設 ∀ 𝑥 [ 𝑃 ( 𝑥 ) → 𝑄 ( 𝑥 ) ] 為真： 這表示對所有 𝑥 ，如果 𝑃 ( 𝑥 ) 為真，那麼 𝑄 ( 𝑥 )
            也必為真。
          </li>
          <li>假設 (∃ 𝑦) 𝑃 ( 𝑦 ) 為真：這表示存在某個 𝑦 使得 𝑃 ( 𝑦 ) 為真。</li>
          <li>
            引入特定個體 𝑐
            <strong>使用 Existential Instantiation</strong>
            ： 由於 (∃ 𝑦) 𝑃 ( 𝑦 ) ，我們可以引入一個特定的個體 𝑐 ，使得 𝑃 ( 𝑐 ) 為真：
          </li>
          <li>
            應用
            <strong>Universal Instantiation</strong>
            到 𝑐 ： 由於 ∀ 𝑥 ( 𝑃 ( 𝑥 ) → 𝑄 ( 𝑥 ) ) 為真，我們可以對特定的 𝑐
            使用這個普遍命題：P(c)→Q(c)
          </li>
          <li>
            <strong>使用 Modus Ponens：</strong>
            由於 𝑃 ( 𝑐 )為真且 𝑃 ( 𝑐 ) → 𝑄 ( 𝑐 ) 為真，我們可以使用 Modus Ponens 推導出 𝑄 ( 𝑐 )
            為真： 𝑄 ( 𝑐 )
          </li>
        </ol>
        <p>
          *以上證明過程 3.4 步驟順序不能相反，因為如果先做4，代入的 a 無法跟題目中的 a
          產生關聯，使得邏輯中的 a 變得可能是 b c 或 d 則無法再證明本 argument。
        </p>
        <p>*證明盡可能早點使用 EI。</p>

        <h4>複雜的案例2</h4>
        <p>證明以下邏輯陳述是 valid argument：</p>
        <p>(∃𝑥)P(𝑥)∧(∃𝑥)Q(𝑥) → (∃𝑥)[P(𝑥)∧Q(𝑥)]</p>
        <h4>命題解讀</h4>
        <p>
          這個命題表示：「如果存在某個 𝑥 使得 𝑃 ( 𝑥 )為真，並且存在某個 𝑥 使得 𝑄 ( 𝑥 )
          為真，則存在某個 𝑥 使得 𝑃 ( 𝑥 ) 和 𝑄 ( 𝑥 ) 同時為真。」
        </p>
        <p>現在，我們將通過證明這個命題不一定為真來展示它其實是無效論證（invalid argument）。</p>
        <h4>證明過程</h4>
        <ol>
          <li>引入假設</li>
          <p>我們假設前提為真，即：</p>
          <p>(∃x)P(x)∧(∃x)Q(x)</p>
          <p>這表示：</p>
          <ul>
            <li>存在一個 𝑥 ，使得 𝑃 ( 𝑥 ) 為真。</li>
            <li>存在一個 𝑥 ，使得 𝑄 ( 𝑥 ) 為真。</li>
          </ul>
          <li>選擇特定個體</li>
          <p>根據前提，我們知道：</p>
          <ul>
            <li>存在一個 𝑎 使得 𝑃 ( 𝑎 ) 為真。</li>
            <li>存在一個 𝑏 使得 𝑄 ( 𝑏 ) 為真。</li>
          </ul>
          <p>
            但重要的是，個體 𝑎 和個體 𝑏 不一定是相同的個體。也就是說，這裡可能有不同的個體 𝑎 使 𝑃 (
            𝑎 ) 為真，以及不同的個體 𝑏 使 𝑄 ( 𝑏 ) 為真。
          </p>
          <li>檢查結論</li>
          <p>
            現在，我們要檢查是否可以推出結論 ( ∃ 𝑥 ) [ 𝑃 ( 𝑥 ) ∧ 𝑄 ( 𝑥 ) ] ，即是否存在某個 𝑥 使得 𝑃
            ( 𝑥 ) 和 𝑄 ( 𝑥 ) 同時為真。
          </p>
          <p>
            然而，從前提中，我們只知道存在一個 𝑎 使得 𝑃 ( 𝑎 ) 為真，並且存在一個 𝑏 使得 𝑄 ( 𝑏 )
            為真。這並不保證 𝑎 = 𝑏 —— 也就是說，並不能確保存在同一個個體 𝑥 同時滿足 𝑃 ( 𝑥 )和 𝑄 ( 𝑥
            ) 。
          </p>
          <li>反例</li>
          <p>讓我們舉個反例來更具體地說明這一點：</p>
          <ul>
            <li>假設 𝑃 ( 𝑥 ) 表示「 𝑥 是一個男人」。</li>
            <li>假設 𝑄 ( 𝑥 ) 表示「 𝑥 是一個女人」。</li>
          </ul>
          <p>
            根據前提，存在一個 𝑥 是男人，存在一個 𝑥 是女人。但顯然，這兩個個體不能是同一個 𝑥
            ，因為一個人不可能同時是男人和女人。因此，不能推出存在某個 𝑥 使得 𝑃 ( 𝑥 ) 和 𝑄 ( 𝑥 )
            同時為真。
          </p>
          <li>結論</li>
          <p>
            這個反例展示了，儘管 𝑃 ( 𝑥 ) 和 𝑄 ( 𝑥 )
            各自都有其存在的個體，但它們不一定是同一個個體，從而無法保證 ( ∃ 𝑥 ) [ 𝑃 ( 𝑥 ) ∧ 𝑄 ( 𝑥 )
            ] 成立。
          </p>
          <p>
            因此，命題 ( ∃ 𝑥 ) 𝑃 ( 𝑥 ) ∧ ( ∃ 𝑥 ) 𝑄 ( 𝑥 ) → ( ∃ 𝑥 ) [ 𝑃 ( 𝑥 ) ∧ 𝑄 ( 𝑥 ) ]
            不是一個有效的論證（valid argument），而是
            <strong>無效的。</strong>
          </p>
        </ol>
        <h4>複雜案例3</h4>
        <p>
          要用謂詞邏輯證明以下論證是有效的： 某些植物是花。 所有花都聞起來香甜。
          因此，某些植物聞起來香甜。
        </p>
        <h5>謂詞邏輯表示</h5>
        <ol>
          <li>
            某些植物是花：
            <p>(∃x)[P(x)∧F(x)]</p>
            <p>這表示存在某個 𝑥 ，使得 𝑥 是植物 𝑃 ( 𝑥 ) 並且 𝑥 是花 𝐹 ( 𝑥 ) 。</p>
          </li>
          <li>
            所有花都聞起來香甜：
            <p>∀x(F(x)→S(x))</p>
            <p>這表示對所有 𝑥 ，如果 𝑥 是花 𝐹 ( 𝑥 ) ，那麼 𝑥 聞起來香甜 𝑆 ( 𝑥 ) 。</p>
          </li>
          <li>
            結論：某些植物聞起來香甜：
            <p>∃x(P(x)∧S(x))</p>
            <p>這表示存在某個 𝑥 ，使得 𝑥 是植物 𝑃 ( 𝑥 ) 並且 𝑥 聞起來香甜 𝑆 ( 𝑥 ) 。</p>
          </li>
        </ol>
        <h5>證明過程</h5>
        <ol>
          <li>
            <p>
              從前提 ∃ 𝑥 ( 𝑃 ( 𝑥 ) ∧ 𝐹 ( 𝑥 ) ) 知道，存在某個 𝑎 ，使得 𝑃 ( 𝑎 ) 為真且 𝐹 ( 𝑎 ) 為真：
            </p>
            <p>P(a)∧F(a)</p>
            <p>這表示有一個特定的個體 𝑎 是植物，並且這個個體 𝑎 是花。</p>
            <p>
              以上使用了 Existential Instantiation，假設有一個特定的個體 𝑎 ，使得 𝑃 ( 𝑎 ) 為真且 𝐹 (
              𝑎 )為真。
            </p>
          </li>
          <li>
            <p>
              從第二個前提 ∀ 𝑥 ( 𝐹 ( 𝑥 ) → 𝑆 ( 𝑥 ) ) 可以得知，對於所有 𝑥 ，如果 𝐹 ( 𝑥 ) 為真，那麼
              𝑆 ( 𝑥 )也為真。將這個規則應用到個體 𝑎 ：
            </p>
            <p>F(a)→S(a)</p>
            <p>因為 𝐹 ( 𝑎 ) 為真，所以可以推導出 𝑆 ( 𝑎 ) 也為真：</p>
            <p>S(a)</p>
            <p>
              這裡使用了 Universal Instantiation，將這個命題應用到具體的個體 𝑎 ，因此得到 𝐹 ( 𝑎 ) →
              𝑆 ( 𝑎 ) 。 這一步將「所有花都聞起來香甜」應用到具體的花 𝑎 上。
            </p>
          </li>
          <li>
            <p>現在我們得知 𝑃 ( 𝑎 ) ∧ 𝑆 ( 𝑎 ) ：</p>
            <p>P(a)∧S(a)</p>
            <p>這表示個體 𝑎 是一個植物，並且 𝑎 聞起來香甜。</p>
            <p>
              推論是使用了 Modus Ponens。已知 𝐹 ( 𝑎 ) 為真，且 𝐹 ( 𝑎 ) → 𝑆 ( 𝑎 ) ，因此可以推導出 𝑆
              ( 𝑎 ) 為真。 這一步是關鍵推理，根據已知前提得出結論 𝑆 ( 𝑎 )。
            </p>
          </li>
          <li>
            <p>因此，我們可以推導出結論 ∃ 𝑥 ( 𝑃 ( 𝑥 ) ∧ 𝑆 ( 𝑥 ) ) ：</p>
            <p>∃x(P(x)∧S(x))</p>
            <p>這表示存在某個植物聞起來香甜。</p>
            <p>
              最後，我們使用了 Existential Generalization，從 𝑃 ( 𝑎 ) ∧ 𝑆 ( 𝑎 ) 推出 ∃ 𝑥 ( 𝑃 ( 𝑥 ) ∧
              𝑆 ( 𝑥 ) )。
              這一步的目的是從具體個體的屬性推廣到一般結論，即「存在某些植物聞起來香甜」。
            </p>
          </li>
        </ol>
        <h5>總結</h5>
        <p>
          這個論證是有效的，因為根據前提，我們從「某些植物是花」和「所有花都聞起來香甜」推導出「某些植物聞起來香甜」。這過程遵循謂詞邏輯的規則，並且結論合理地從前提得出。
        </p>
        <h3>Existential Generalization(EG)</h3>
        <h3>Universal Generalization(UG)</h3>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
