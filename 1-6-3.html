<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-6-3">1-6-3 React: 資料狀態管理<h2>
          <p>為什麼需要資料狀態管理，資料狀態管理到底在解決什麼樣的問題？這其實是架構、元件化帶來的概念。還是舉先前案例：在一個頁面上，點擊其中一處「訂閱」按鈕後，真面中的其他「訂閱」按鈕也會切換為「已訂閱」狀態。如果沒有資料狀態，也許就需要用以下方式來實現訂閱需求。</p>
        <h3 ></h3>
        <pre><code class="language-js">
const btnEle1 = $('#btn1')
const btnEle2 = $('#btn2')
btnEle1.on('click', () => {
  if(btnEle1.textContent ==='已訂閱'){
    return
  }
  btnEle1.textContent ='已訂閱'
  btnEle2.textContent ='已訂閱'
})
btnEle2.on('click', () => {
  if(btnEle2.textContent ==='已訂閱'){
    return
  }
  btnEle1.textContent ='已訂閱'
  btnEle2.textContent ='已訂閱'
})

        </code></pre>
        <p>這只是兩個按鈕的情況，處理起來就非常混亂了，而且難以維護，在這種情況下非常容易滋生 bug。</p>
        <p>現代化的架構解決這個問題的想法是元件化，元件依賴資料，對應這個場景的資料狀態的程式如下。</p>
        <pre><code class="language-js">
hasMarked: false / true
        </code></pre>
        <p>根據 hasMarked 這個狀態值，所有的訂閱元件都可以回應正確的視圖操作。把麵條式的程式轉換成可維護的程式後，對資料的管理就成了重中之重，這就是資料狀態的雛形。但是，一旦資料量越來越大，如何與元件形成良好的互動就是一種學問了。舉例來說，要考慮以下情況。</p>
        <ul>
          <li>一個元件需要和另一個元件共用狀態。</li>
          <li>一個元件需要改變另一個元件的狀態。</li>
        </ul>
        <p>以 React 為例，其他架構類似，如果 React 自己來維護這些資料，則資料狀態就是一個物件，並且這個物件在元件之間要互相修改，極其混亂。</p>
        <p>要考慮一個問題：hasMarked 這種資料到底是應該放在 state中維護，還是應該借助資料狀態管理類別庫，如 Redux，來維護呢？至少這樣一來，資料來源是單一的，資料狀態和元件是解耦的，也更加方便開發者進行偵錯和擴充資料。</p>
        <p>以 React 的state 和Redux為例，來分析一下「資料由誰來維護」的問題。</p>
        <p>React 的 state 是在元件內部維護的資料，當某項 state 需要與其他元件共用時，我們就可以透過 props 來完成元件間的通訊。從實作上來看，這就需要相對頂層的元件維護共用的 state 並提供修改此項 state 的方法。state 本身和修改方法都需要透過 props 傳遞給子孫元件。
        </p>
        <p>使用 Redux 的時候，在 Redux store 中維護資料。任何需要存取並更新資料的元件都需要連線 Redux，完成對 Redux store 的訂閱，這通常借助容器元件來完成。Redux 對資料採用集中管理的方式。</p>
        <p>從資料持久度、資料消費範圍的角度來回答這個問題。首先，在資料持久度上，不同狀態的資料大致可以分為以下3大類。</p>
        <ul>
          <li>快速變更型：這種資料在應用中代表了某些原子等級的資訊，且顯著特點是變更頻率最快。舉例來說，一個文字輸入框中的資料值可能會隨著使用者輸入在短時間內持續發生變化。這種資料顯然更適合在 React 元件內維護。</li>
          <li>中等持續型：在使用者瀏覽或使用應用時，這種資料常常會在頁面更新前保持穩定。舉例來說，從非同步請求介面透過 AJAX方式得來的資料，或使用者在個人中心頁編輯提交的資料。這種資料較為通用，也許會被不同元件所使用。資料在 Redux store 中維護，並透過 connect 方法和元件進行連接，是一種不錯的選擇。</li>
          <li>長遠穩定型：指在頁面多次更新或多次存取期間都保持不變的資料。因為
Redux store 會在每次真面掛載後都重新產生一份新的資料，因此這種類型的資料顯然應該儲存在Redux以外的地方，如伺服器端資料庫或瀏覽器的本機存放區。</li>
        </ul>
        <p>即資料消費範圍上來分析。資料特性表現在消費層面，即有多少元件需要使用。我們以此來區分 Rcact 和 Redux 的不同分工。
廣義上，需要消費同一種資料的元件越多，在 Redux store 中維護這種資料就越合理；反之，如果某種資料與其他資料隔離，只服務於應用中某單一部分，那麼由 React 維護更加合理。</p>
        <p>實際來看，共用的資料應該存在於 React 的高層元件中，由此在低層元件一層層傳遞。如果在 props 傳遞深度上只需要一兩個層級就能滿足消費資料的元件需求，那麼這樣的跨度是可以接受的；反之，如果跨越層級很多，那麼連結到的所有中間層級的元件就都需要進行接力賽式的傳遞，這樣顯然會增加很
          多乏味的傳遞程式，也破壞了中間元件的重複使用性。這時，使用Redlx維護共用狀態，合理設定容器元件，透過 comeet來打通資料，就是一種更好的方式。</p>
          <p>如果一些完全不存在父子關係的元件需要共用資料，舉例來說，前面提到過的真面需要在多處展示使用者圖示，那麼常常會造成資料輻射分散的問題，對於React 模式的狀態管理十分不利。在這種場景下，使用 Redux 同樣是更好的選擇。</p>
          <p>如果應用有追蹤狀態的功能，舉例來說，需要完成「重放」「返回」或 "Redo/Undo" 等需求，那麽使用 Redux 無疑是最佳選擇，因為 Redux 天生擅長於此：每一個 action 都描述了資料狀態的改變和更新，非常便於進行資料的集中管理。</p>
          <p>Redux 可以被任何一個資料管理類別庫所取代。</p>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
