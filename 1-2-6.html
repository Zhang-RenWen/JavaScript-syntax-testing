<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-2-6">1-2-6 Promise 深入解析</h2>
        <h3>Promise 化一個 API</h3>
        <p>微信小程式環境中發送一個網路請求時會使用 路請求時會使用 wx.request()。</p>
        <pre><code class="language-js">
wx.request({
  url: 'test', // 範例
  data: {
    x: '',
    y: ''
  },
  header: {
    'content-type': 'application/json' // 預設值
  },
  success(res) {
    console.log(res)
  }
})
        </code></pre>
        <p>
          這樣的設計有一個小問題，就是容易出現「回呼地獄」問題。如果我們想先透過，userInfo
          介面來取得登入使用者資訊資料，再從登入使用者資訊資料中透過請求 ./${id}/friendList
          介面來取得登入使用者的所有好友清單，那麼就需要執行以下程式。
        </p>
        <pre><code class="language-js">
wx.request({
  url: './userInfo',
  success(res) {
    const id = res.data.id
    wx.request({
      url: `./${id}/friendList`,
      success(res) {
        console.log(res)
      }
    })
  }
})
        </code></pre>
        <p>
          解決「回呼地獄」問題的極佳工具就是 Promise，所以將微信小程式wx.request() 方法進行Promise
          化，程式將變為如下所示的樣子。
        </p>
        <pre><code class="language-js">
const wxRequest = (url, data = {}, method = 'GEI') =>
  new Promise((resolve, reject) => {
    wx.request({
      uri,
      data,
      method,
      header: {
        // 通用化header設定
      },
    success: function (res) {
      const code = res.statusCode

      if (code !== 200) {
        reject({ error: 'request fail', code })
        return
      }
      resolve(res.data)
    },
    fail: function (res) {
      reject({ error: 'request fail' })
    }
  })
})
        </code></pre>
        <p>Promise 化更多類似（透過 success 和 fail代表狀態）的介面，程式如下。</p>
        <pre><code class="language-js">
const promisify = (fn) => (args) =>
  new Promise((resolve, reject) => {
    args.success = function (res) {
      return resolve(res)
    }
    args.fail = function (res) {
      return reject(res)
    }
  })

        </code></pre>
        <p>在將 Promise 化的程式封裝為 promisify 之後，我們便可以像以下程式所示的 那樣使用。</p>
        <pre><code class="language-js">
const wxRequest = promisify(wx.request)
        </code></pre>
        <p>
          透過以上實例，我們知道． Promise 其實就是一個建構函數，我們可以使用這個建構函數建立一個
          Promise 寶例。該建構函數很簡單，它只有一個參數，按照 Promise/A+ 標準的命名。我們把 Promise
          建構函數的參數叫作 executor：區是函數類型的參數。這個函數又「自動」具有 resolve 、reject
          兩個方法作為參數。
        </p>
        <p>我們可以根據此結論開始實現 Promise 的第一步，先簡單地實現一個建構函數，程式如下:</p>
        <pre><code class="language-js">
function Promise (executor) {

}
        </code></pre>
        <p>
          在上面的 wx.request() 介紹中，我們將其進行了 Promise
          化，因此在巢狀結構回呼場景中可以使用以下方法。
        </p>
        <pre><code class="language-js">
wxRequest('./userInfo')
.then(
  (data) => wxRequest(`./${data.id}/friendList`),
  (error) => console.log(error)
)
.then(
  (data) => {
    console.log(data)
  },
  (error) => {
    console.log(error)
  }
)
        </code></pre>
        <p>
          Promise 建構函數傳回一個 Promise 物件實例，這個傳回的 Promise 物件具有一個then
          方法。在then 方法中，呼叫者可以定義兩個參數，分別是 onfulfilled 和
          onrejected，它們都是函數類型的參數。其中，onfulfilled 透過參數可以取得 Promise 物件經過
          resolve 處理後的值，onrejected 可以取得 Promise 物件經過 reject
          處理後的值。透過這個值，我們來處理非同步作業完成後的邏輯。
        </p>
        <p>
          這些都是 Promise/A+ 標準的基本內容，接下來我們繼續實現 Promise。在已有 Promise
          建構函數的基礎上加上 then 原型方法的骨架，程式如下。
        </p>
        <pre><code class="language-js">
function Promise (executor) {

}

Promise.prototype.then = function (onfulfilled, onrejected) {

}
        </code></pre>
        <p>下面先來看一個範例，從範例中了解 Promise 的重點內容。</p>
        <pre><code class="language-js">
let promise1 = new Promise((resolve, reject) => {
  resolve('data')
})
promise1.then((data) => {
  console.log(data)
})
let promise2 = new Promise((resolve, reject) => {
  reject('error')
})
promise2.then(
  (data) => console.log(data),
  (error) => {
    console.log(error)
  }
)
        </code></pre>
        <p>
          在使用 new 關鍵字呼叫 Promise 建構函數時，在合適的時機（常常是非同步作業結束時）呼叫
          executor 的參數 resolve，並將經過 resolve 處理後的值作為 resolve
          的函數參數執行，這個值便可以在後續 then
          方法的第一個函數參數（onfulfilled）中拿到；同理，在出現錯誤時，呼叫 executor 的參數
          reject，並將錯誤訊息作為 reject 的函數參數執行，這個錯誤訊息可以在後續then
          方法的第二個函數參數（onrejected）中獲得。
        </p>
        <p>
          因此，我們在實現Promise 時，應該有兩個變數，分別儲存經過 resolve 處理後的值，以及經過
          reject 處理後的值（當然，因為 Promise狀態的唯一性，不可能同時出現經過 resolve
          處理後的值和經過 reject
          處理後的值，因此也可以用一個變數來儲存）；同時還需要存在一個狀態，這個狀態就是 Promise
          實例的狀態（pending、fulfilled、rejected）；最後要提供 resolve 方法及 reject方
          法，兩個方法需要作為 executor 的參數提供給開發者使用，程式如下。
        </p>
        <pre><code class="language-js">
function Promise(executor) {
  const self = this
  this.status = 'pending'
  this.value = null
  this.reason = null
  function resolve(value) {
    self.value = value
  }
  function reject(reason) {
    self.reason = reason
  }
  executor(resolve, reject)
}

Promise.prototype.then = function (
  onfulfilled = Function.prototype,
  onrejected = Function.prototype
) {
  onfulfilled(this.value)
  onrejected(this.reason)
}
        </code></pre>
        <p>
          為了確保 onfulfilled、onrejected
          能夠穩固地執行，我們為其設定了預設值，其預設值為一個函數元（Function.prototype）。
        </p>
        <p>
          注意，因為 resolve
          的最後呼叫是由開發者在不確定環境下（常常是在全域中）直接呼叫的，因此為了在 resolve
          函數中能夠拿到 Promise實例的值，我們需要對 this 進行儲存，上述程式中使用了 self變數來記錄
          this，也可以使用箭頭函數來確保 this 執行的準確性。
        </p>
        <pre><code class="language-js">
function Promise(executor) {
  this.status = 'pending'
  this.value = null
  this.reason = null

  const resolve = (value) => {
    this.value = value
  }
  const reject = (reason) => {
    this.reason = reason
  }

  executor(resolve, reject)
}

Promise.prototype.then = function (
  onfulfilled = Function.prototype,
  onrejected = Function.prototype
) {
  onfulfilled(this.value)
  onrejected(this.reason)
}
        </code></pre>
        <p>
          每個 Promise 實例的 then
          方法邏輯都是一致的，實例在呼叫該方法時，可以透過原型（Promise.prototype）來呼叫，而不需要每次產生實體都新建立一個
          then 方法，以便節省記憶體，顯然更合適。
        </p>
        <h3>Promise 實現狀態增強</h3>
        <pre><code class="language-js">
let promise = new Promise((resolve, reject) => {
  resolve('data')
  reject('error')
})
promise.then(
  (data) => {
    console.log(data)
  },
  (error) => {
    console.log(error)
  }
)
        </code></pre>
        <p>
          以上程式只會輸出 data。我們知道，Promise 實例的狀態只能從 pending 變為 fulfilled，或從
          pending 變為 rejected。狀態一旦愛更完畢，就不可再次變化或逆轉。也就是說，如果一旦變為
          fulfilled，就不能再變為 rejected；一旦轉為 rejected ，就不能再變為 fulfilled。
        </p>
        <p>
          而上段程式實現顯然無法滿足這一特性。要執行上一段程式輸出 data 及
          error，需要對狀態進行判斷和增強，如下。
        </p>
        <pre><code class="language-js">
function Promise(executor) {
  this.status = 'pending'
  this.value = null
  this.reason = null

  const resolve = (value) => {
    if (this.status === 'pending') {
      this.value = value
      this.status = 'fulfilled'
    }
  }
  const reject = (reason) => {
    if (this.status === 'pending') {
      this.reason = reason
      this.status = 'rejected'
    }
  }
  executor(resolve, reject)
}

Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : (data) => data
  onrejected =
    typeof onrejected === 'function'
      ? onrejected
      : (error) => {
          throw error
        }
  if (this.status === 'fulfilled') {
    onfulfilled(this.value)
  }
  if (this.status === 'rejected') {
    onrejected(this.reason)
  }
}
        </code></pre>
        <p>
          可以看到：resolve和 reject 方法中加入了判斷，只允許 Promise 實例狀態從 pending 變為
          fulfilled，或從 pending 變為 rejected。
        </p>
        <p>
          同時注意、這裡對 Promise.prototype.then 的參數 onfulfilled 和 onrejected
          進行了判斷，當實際參數不是函數類型時，就需要指定預設函數值。這時的預設值不再是函數元
          Function.prototype 了。
        </p>
        <p>
          不過 Promise
          是用來解決非同步問題的，而我們的程式全部都是同步執行的，似乎還差了更重要的邏輯。
        </p>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
  <script></script>
</html>
