<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript-syntax-learning</title>
  <link rel="stylesheet" href="./hightlight/default.min.css" />
  <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
  <link rel="stylesheet" href="./css/main.css" />
  <script src="./hightlight/hightlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <nav>
    <h1>現代 Javascript 實務應用</h1>
  </nav>
  <main>
    <aside></aside>
    <section>
      <h2>4-4 非同步函式</h2>
      <h3 id="4-4-1">
        4-4-1 非同步函式的意義
      </h3>
      <P>
        假設我們有一段如下方的程式碼，其中fetch 請求被包裹於
        getRandomArticle 函式中；當請求成功時，所回傳的 Promise 物件為已實現並附帶 JSON 格式的 body 主體資訊；若失敗，則依循標準的 fetch
        已拒絕機制處理‧
      </P>
      <pre><code class="language-js">
function getRandomArticle(){
  return fetch('/articles/random', {
    headers: new Headers({
      Accept:'application/json'
    })
  })
  .then(res =&gt; res.json())
}
        </code></pre>
      <p>
        下一段程式碼則說明 getRandomArticle 函式基本的運用方式。我們會建立一個 Promise 物件鏈結，它會擷取文章的JSON 物件，並傳遞至非同步的 renderView 的畫面描繪函式，在完成後會產生一個
        HTML 頁面，接著再以該 HTML 頁面取得我們的頁面内容。為了避免無法捕捉到的錯誤，我們利用 console.error 可將所有發生的拒絕原因輸出。
      </p>
      <pre><code class="language-js">
getRandomArticle()
.then(model =&gt; renderView(model))
.then(html =&gt; setPageContents(html))
.then(() =&gt; console.log('Successfully changed page!'))
.catch(err =&gt; console.error (err))
        </code></pre>
      <p>
        Promise 物件鏈結是很難除錯的：流程控制的錯誤原因很難追溯，且撰寫以 Promise 物件為基礎的程式碼流程，閱讀起來是比撰寫更加不易，常會導致後續維護上的困難。
      </p>
      <p>
        如果是單使用單純 JavaScript 回呼函式,我們的程式碼內容會較具重複性，就如接下來的範例一樣。同時,也落入回呼困境:在非同步程式流程中的每一個步驟都再加入一層縮排,使得程式碼更難閱讀理解。
      </p>
      <pre><code class="language-js">
getRandomArticle( (err, model) =&gt;{
  if (err) {
    return console.error(err)
  }
  renderView(model, (err, html) =&gt; {
    if (err) {
      return console.error(err)
    }
    setPageContents (html, err =&gt; {
      if (err) {
        return console.error(err)
      }
      console.log('Successfully changed page!')
    })
  })
})
        </code></pre>
      <p>當然,以函式庫可以解決回呼困境,和錯誤處理的重複性·函式庫的使用可受惠於標準化回呼函式的優點,如 async 非同步,將第一個引數保留給錯誤使用。若使用它的 waterfall 方法,我們的程式又會變得更簡潔一些。</p>
      <pre><code class="language-js">
async.waterfall([
  getRandomArticle,
  renderView,
  setPageContents
  ], (err, html) =&gt;{
    if (err){
      return console.error(err)
    }
    console.log('Successfully changed page! ')
  }
)
        </code></pre>
      <p>
        我們再看一個類似的範例，但這次我們將使用產生器。下面的範例是 getRandomArticle 的重製版，此處我們使用產生器以改變 getRandomArticle 的使用方式。
      </p>
      <pre><code class="language-js">
function getRandomArticle(gen) {
  const g = gen()
  fetch('/articles/random', {
  headers: new Headers({
      Accept: 'application/json'
    })
  })
  .then(res =&gt; res.json())
  .then(json =&gt; g.next(json))
  .catch(err =&gt; g.throw(err))
}
        </code></pre>
      <p>以下的程式碼展示如何透過 yield 運算式，自 getRandomArticle 函式中擷取 json
        結果值。即使看起來像是同步進行，現在其實已加入了產生器函式。當我們希望加入更多步驟時，必須大幅更動getRandomArticle ，才能夠以 yield 出產期望的結果值；並需調整產生器內容，以使用最新的結果序列。</p>
      <pre><code class="language-js">
getRandomArticle( function* printRandomArticle() {
  const json = yield
  // render view
})
        </code></pre>
      <p>
        在此案例中，使用產生器可能不是達到我們期望的結果最直覺的方式：只是把複雜性搬移到其他地方而已，而我們也受限於 Promise 的使用。
      </p>
      <p>
        除了將不直覺的語法加入其中，迭代器的程式碼也將與使用中的產生器函式高度地結合；這表示當產生器程式碼中加入了 yield 運算式，迭代器的程式碼也必須一併調整。
      </p>
      <p>
        另一個較佳的方案是使用 async 函式。
      </p>
      <h3 id="4-4-2">
        4-4-2 使用 async/await
      </h3>
      <p>非同步函式可讓我們採用以 Promise 物件為基礎的實作，同時也受益於外觀看似同步的產生器。這種方法的一個巨大優點是，你將完全不需要變更原始的 getRandomArticle 函式：只要它回傳一個可被等候的
        Promise 物件。</p>
      <p>
        請注意，await 只能夠在非同步函式中使用，函式須以關鍵宇 async 標示。非同步函式的運作類似於產生器，可在本文中暫停執行直到 Promise 物件已確認狀態為止。若被等待的運算式並不是一個 Promise
        物件，則會被轉換型態為 Promise 物件。
      </p>
      <p>
        下面的程式碼使用我們最初的 getRandomArticle 函式，它使用 Promise 物件進行運作。接著它會透過一個名稱為renderView的非同步函式，傳回 HTML 結果更新頁面内容。請注意我們如何使用
        try/catch 在被等候的 Promise 物件中進行錯誤理,就如我們在同步程式操作一樣。
      </p>
      <pre><code class="language-js">
async function read() {
  try {
    const model = await getRandomArticle()
    const html = await renderView(model)
    await setPageContents(html)
    console.log('Successfully changed page!')
  } catch (err) {
    console. error (err)
  }
 }

read()
      </code></pre>
      <p>
        非同步函式均會回傅一個 Promise 物件。萬一發生末捕捉的錯誤時，則回傅已拒絕的 Promise 物件。此外，回傳的物件也可解析為回傳值。非同步函式允許我們將這兩種回傳型態與一般以 Promise
        物件為基礎的方法繼續搭配使用。下面範例說明如何將這兩種回傳型態結合運用。
      </p>
      <pre><code class="language-js">

      </code></pre>
      <pre><code class="language-js">
async function read() {
  const model = await getRandomArticle()
  const html = await renderView(model)
  await setPageContents(html)
  return 'Successfully changed page!'
}

read()
.then(message =&gt; console.log (message))
.catch(err =&gt; console.error (err))
      </code></pre>
      <p>
        若要護 read 函式更具再利用性，我們可以將 html 結果回傳，並允許使用者利用Promise 或其他的非同步函式進行後續處理。這樣你的 read 函式功能就可以專注於擷取頁面的 HTML 內容。
      </p>
      <pre><code class="language-js">
async function read() {
  cost model = await getRandomArticle()
  const html = await renderView(model)
  return html
}
      </code></pre>
      <p>
        在下面範例中 ，我們運用單純的 Promise 物件將 HTML 輸出。
      </p>
      <pre><code class="language-js">
read().then(html =&gt; console.log(html))
      </code></pre>
      <p>
        使用非同步函式對後續的處理也較不會那麼困難。在下方的程式碼中，我們建立了一個 write 函式，作為後續的應用處理。
      </p>
      <pre><code class="language-js">
async function write() {
  const html = await read()
  console.log(html)
}
      </code></pre>
      <p>
        那同時進行的非同步流程會如何呢?
      </p>
      <pre><code class="language-js">

      </code></pre>
      <h3 id="4-4-3">
        4-4-3 同時發生的非同步流程
      </h3>
      <p>
        在非同步程式碼的流程中，經常會同時地執行兩個或多個工作。利用非同步函式可以很容易的撰寫非同步程式，同時在程式上也將它們以一次進行一個非同步操作的方式撰寫。一個函式若有多個 await 運算式在其中，則在每一個await
        運算執行時會暫停一次，直到 Promise 狀態確認，恢復運作並至下一個 await 運算之前一這和我們所看到的產生器與 yield 運算式的案例類似。
      </p>
      <pre><code class="language-js">
async function concurrent (){
  const p1 = new Promise(resolve=&gt;
  setTimeout (resolve, 500,'fast')
)
  const p2 = new Promise (resolve=&gt;
  setTimeout (resolve, 200,'faster')
)
  const p3 = new Promise (resolve =&gt;
  setTimeout (resolve, 100,'fastest')
)
  const r1 = await p1 // 運作會暫停，直到 p1 己確認狀態
  const r2 = await p2
  const r3 = await p3
}
      </code></pre>
      <p>
        我們可以使用 Promise.all 修正此問題，透過建立一個我們可以 await 的 Promise 物件。和用此方式，我們的程式碼運作會暫停，直到清單中的每一個 Promise 物件都確認狀態後，它們就同時地完成解析。
      </p>
      <p>
        下面的範例示範如何利用 await 等待三個不同的 Promise 物件並同時完成解析。假定 await 暫停了你的 async 函式，且 await Promise.all 運算式最終會將解析結果置於 results
        結果陣列中。你可以利用解構賦值的方式將每一個結果值自陣列中取出。
      </p>
      <pre><code class="language-js">
async function concurrent (){
  const p1 = new Promise(resolve=&gt;
    setTimeout (resolve, 500,'fast')
  )
  const p2 = new Promise(resolve=&gt;
    setTimeout (resolve, 200,'faster')
  )
  const p3 = new Promise(resolve=&gt;
    setTimeout (resolve, 100,'fastest')
  )
  const [r1, r2, r3] = await Promise.all([p1, p2, p3])
  console.log(r1, r2, r3)
  //'fast','faster','fastest'
}
      </code></pre>
      <p>
        我們可以使用 Promise.race 自較早實現的 Promise 物件中取得結果。
      </p>
      <pre><code class="language-js">
async function race (){
  const p1 = new Promise(resolve=&gt;
    setTimeout (resolve, 500,'fast')
  )
  const p2 = new Promise(resolve=&gt;
    setTimeout (resolve, 200,'faster')
  )
  const p3 = new Promise(resolve=&gt;
    setTimeout (resolve, 100,'fastest')
  )
  const result = await Promise.race([p1, p2, p3])
  console.log(result)
  // 'fastest'
}
              </code></pre>
      <h3 id="4-4-4">
        4-4-4 錯誤處理
      </h3>
      <pre><code class="language-js">

      </code></pre>
      <h3 id="4-4-5">
        4-4-5 了解非同步函式的內部運作
      </h3>
      <pre><code class="language-js">

      </code></pre>
      <div class="border-block"></div>
    </section>
  </main>
</body>
<script src="./menu.js"></script>

</html>